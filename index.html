<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>潘迪海</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="潘迪海">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="潘迪海">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="潘迪海">
  
    <link rel="alternative" href="/atom.xml" title="潘迪海" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.266c1c.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>
</html>
<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://s2.ax1x.com/2020/02/15/1xGEBn.th.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">jackiecookie</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/jackiecookie" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://s2.ax1x.com/2020/02/15/1xGEBn.th.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">jackiecookie</h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/jackiecookie" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/随笔/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-javascript垃圾回收机制" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/javascript垃圾回收机制/">javascript垃圾回收机制</a>
    </h1>
  

        
        <a href="/2019/07/01/javascript垃圾回收机制/" class="archive-article-date">
  	<time datetime="2019-07-01T02:53:41.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-07-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var theThing = null;</span><br><span class="line">var replaceThing = function () &#123;</span><br><span class="line">  var originalThing = theThing;</span><br><span class="line">  var c = &apos;a&apos;</span><br><span class="line">  function unused() &#123;</span><br><span class="line">    if (originalThing) &#123;</span><br><span class="line">      console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(&apos;1111&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure></p>
<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>
<ol>
<li>识别哪些对象需要被回收。</li>
<li>回收/重复使用需要被回收对象的内存。</li>
<li>压缩/整理内存(有些可能没有)</li>
</ol>
<p>而常见的识别对象是否需要回收的机制有下面几种:</p>
<ul>
<li>引用计数 (Python)</li>
<li>逃逸分析 (Java)</li>
<li>Tracing/Reachable 追踪分析 (javascript)</li>
</ul>
<p>今天就主要看一下V8中GC的具体实现方式</p>
<h2 id="Tracing-Reachable-追踪分析"><a href="#Tracing-Reachable-追踪分析" class="headerlink" title="Tracing/Reachable 追踪分析"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>
<h2 id="The-Generational-Hypothesis"><a href="#The-Generational-Hypothesis" class="headerlink" title="The Generational Hypothesis"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>
<h3 id="Scavenger"><a href="#Scavenger" class="headerlink" title="Scavenger"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>
<p><img src="http://img.pandihai.com/03.svg" alt="第一次GC"><center><font color="gray" size="2">第一次GC</font></center></p>
<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>
<p><img src="http://img.pandihai.com/04.svg" alt="第二次GC"><center><font color="gray" size="2">第二次GC</font></center></p>
<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>
<h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>
<p><img src="http://img.pandihai.com/05.svg" alt="Scavenger平行调度"><center><font color="gray" size="2">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>
<h4 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>
<p><img src="http://img.pandihai.com/09.svg" alt="Major GC同步调度"><center><font color="gray" size="2">Major GC同步调度</font></center></p>
<h3 id="什么时候会执行GC"><a href="#什么时候会执行GC" class="headerlink" title="什么时候会执行GC"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>
<p>我们可以通过手动设置来设置新生代和老代的space大小:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=<span class="number">1700</span> index.js</span><br><span class="line">node --max-<span class="keyword">new</span>-space-size=<span class="number">1024</span> index.js</span><br></pre></td></tr></table></figure></p>
<h4 id="空闲时GC"><a href="#空闲时GC" class="headerlink" title="空闲时GC"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback" target="_blank" rel="noopener">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">React 16 fiber的实现</a>)。</p>
<p><img src="http://img.pandihai.com/10.svg" alt="空闲时GC"><center><font color="gray" size="2">利用主线程空闲时间进行GC</font></center></p>
<h4 id="Incremental"><a href="#Incremental" class="headerlink" title="Incremental"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>
<p><img src="http://img.pandihai.com/06.svg" alt="Incremental"><center><font color="gray" size="2">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>
<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>
<ol>
<li>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</li>
<li>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</li>
<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">from</span>-space                                to-space</span><br><span class="line"></span><br><span class="line">theThing         (reachable)                theThing</span><br><span class="line">replaceThing     (reachable)                replaceThing</span><br><span class="line">unused                                      originThing</span><br><span class="line">originThing      (reachable)       =&gt;       longStr  </span><br><span class="line">c                                           someMethod</span><br><span class="line">longStr          (reachable)                </span><br><span class="line">someMethod       (reachable)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>
</li>
<li>第二次GC开始</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">from</span>-space                                to-space                           old-space</span><br><span class="line"></span><br><span class="line">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class="line">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class="line">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class="line">originThing      (reachable)       =&gt;       <span class="function"><span class="params">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class="line">c                                           someMethod</span><br><span class="line">longStr          (reachable)                </span><br><span class="line">someMethod       (reachable)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     old-space</span><br><span class="line">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class="line">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class="line">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class="line">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class="line">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>主要导致内存泄漏的原因是</p>
<p><img src="http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png" alt="闭包是在声明的时候被创建的"><center><font color="gray" size="2">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>
<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var theThing = null;</span><br><span class="line">var replaceThing = function () &#123;</span><br><span class="line">  var originalThing = theThing;</span><br><span class="line">  var c = &apos;a&apos;</span><br><span class="line">  function unused() &#123;</span><br><span class="line">    if (originalThing) &#123;</span><br><span class="line">      console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(&apos;1111&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/07/01/javascript垃圾回收机制/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-javascript基础-prototype" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/javascript基础-prototype/">javascript基础:prototype</a>
    </h1>
  

        
        <a href="/2019/04/20/javascript基础-prototype/" class="archive-article-date">
  	<time datetime="2019-04-20T08:27:37.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-04-20</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在  了解 prototype 之前，你需要了解 javascript 中  的对象。你也许听过这样一句话 <strong>javasctipt 中一切都是对象。</strong> 在 javascript 中主要有两种类型</p>
<ol>
<li>Primitives — Strings, Numbers, Booleans, Undefined, and Null.</li>
<li>Objects — Arrays, Functions, Dates</li>
</ol>
<p>即使看起来这些并不是所有的类型都是 Object,但是所有的非 Object 类型在 javascript 编译的时候都会被包装成一个对象,这个叫 javascript 中被称为 <strong>“包装对象(wrapper primitive into Object)”</strong>。另外你还需要知道对象是怎么被创建的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> foo();</span><br><span class="line"></span><br><span class="line">o.fn();</span><br></pre></td></tr></table></figure>
<p>这里new会做4件事</p>
<ol>
<li>创建一个全新的对象。</li>
<li>将这个全新的对象的prototype指向他创建方法的prototype属性。</li>
<li>将这个对象绑定到this关键字传入到方法中。</li>
<li>将对象返回。</li>
</ol>
<h3 id="什么是-prototype"><a href="#什么是-prototype" class="headerlink" title="什么是 prototype"></a>什么是 prototype</h3><p>在你了解了对象的基本内容，并且自己创建过对象之后,其实你已经跟 prototype 打过交道了。简单来说<strong>prototype 就是对象中的一个属性,他<em>指向</em>(link to)另外的一个对象.</strong></p>
<p>对于前面的例子,当你有一个方法foo的时候,编译器会同时创建一个对象foo,接下来我们创建了一个对象o,在对象中访问原型可以使用<code>o.__proto__</code>,这时对象o指向foo的对象。(javascript中方法访问和设置原型用属性<code>prototype</code>,对象用<code>__proto__</code>)</p>
<h3 id="原型链-prototype-chains"><a href="#原型链-prototype-chains" class="headerlink" title="原型链(prototype chains)"></a>原型链(prototype chains)</h3><p>那么 prototype 到底有什么用呢? 在 javascript 中当你访问一个对象没有的属性时候,编译器会顺着<strong>原型链</strong>一直直到找到这个属性或者到达原型链的顶端的null,而null没有prototype。所有原型链的顶端最终都指向Object对象,而Object.prototype是null。</p>
<h3 id="原型有什么用"><a href="#原型有什么用" class="headerlink" title="原型有什么用"></a>原型有什么用</h3><p>javascript 是一个面向对象的语言(OOP),他最早是受到 Java,Scheme 和 Self 语言的启发,但是 javascript 没有选择向 Java 一样基于 Class 来创建对象,而是选择像 Self 一样基于原型来创建对象(Self 也是最早的基于原型的编程语音)。一个面向对象的语言就有三个要素：封装(Encapsulation),继承(Inheritance),多态(Polymorphism).而 javascript 是基于原型来实现继承的(prototypal inheritance).</p>
<p>如果你有一个 dog 类型,你可以这样来继承 animal 类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  bark: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我是动物"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  __proto__: animal</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dog.bark(); <span class="comment">//我是动物</span></span><br></pre></td></tr></table></figure>
<p>如果把代码稍微修改一下那么就可以实现多态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  bark: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我是"</span> + <span class="keyword">this</span>.type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  type: <span class="string">"狗"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">  __proto__: animal,</span><br><span class="line">  type: <span class="string">"猫"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dog.bark(); <span class="comment">//我是狗</span></span><br><span class="line">cat.bark(); <span class="comment">//我是猫</span></span><br></pre></td></tr></table></figure>
<h3 id="Class和Protptype比较"><a href="#Class和Protptype比较" class="headerlink" title="Class和Protptype比较"></a>Class和Protptype比较</h3><p>那么相比较于基于class来创建对象，基于Prototype来创建对象有什么区别呢?</p>
<p>我觉得最大的区别就是 基于class创建的对象会<strong>拷贝</strong>class的属性,而基于prototype创建的对象会通过prototype<strong>连接(link to)</strong>他的父类(这种方式更像是对象代理).也就是说当你在运行时添加或者删除父类中的属性,当子类被访问到他自己没有的属性时,编译器会随着prototype找到父类新添加的属性。而class是类似拷贝的行为,已经创建的对象,父类发生了属性的添加或者删除,并不会影响到子类。相比较而言PBG(prototype base programming)最主要的优势是他会更灵活,更灵活就有可能会有更多的bug。而基于class编程更严格,这样的代码就会更健壮相对来说bug就会少一点。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在javascript中,继承是依靠原型链来实现的。所有的object,array,functiond都有原型,所有的原型最终都指向Obejct,而Object.prototype指向null。当访问对象的属性的时候,如果这个属性在当前这个对象中没有找到,编译器会顺着原型链一直找这个属性,一直到找到或者到null为止。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><em>composition vs inheritance</em></p>
<p><em>javascript delegation vs inheritance</em></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/04/20/javascript基础-prototype/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-react-fiber源码学习1" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/react-fiber源码学习1/">react-fiber源码学习1</a>
    </h1>
  

        
        <a href="/2018/01/12/react-fiber源码学习1/" class="archive-article-date">
  	<time datetime="2018-01-12T06:52:19.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-01-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##准备</p>
<p>react-render可以允许我们自己定义的render把react组件渲染到不同的环境中,现在已经可以渲染在很多的平台中比如:浏览器(react-dom),ios装置(react-native),安卓(react-native),VR(react-vr),pdf(react-pdf)等等地方,完成一个对应环境的config就可以把组件渲染到对应的环境中.而使用的react的底层核心代码(Fiber,Scheduler,Reconciler)是同一个,这里就从自己比较熟悉的浏览器前端来介绍源码.</p>
<h3 id="什么是react-fiber"><a href="#什么是react-fiber" class="headerlink" title="什么是react-fiber?"></a>什么是react-fiber?</h3><p>fiber是react6.0以后引入的一个新的核心算法,react历时了两年重新重写了react的核心算法.</p>
<h3 id="fiber能带来什么"><a href="#fiber能带来什么" class="headerlink" title="fiber能带来什么?"></a>fiber能带来什么?</h3><p>我们都知道javascript是一个单线程的语言,以浏览器为例之前的react在浏览器中使用调用堆栈来管理操作,而react引入了一个优先级的新概念(优先级之前在ng中已经被提出过),也重新自己实现了stack,我们可把一个fiber理解为一个stack帧(stack frame)他把每一次操作和渲染做切分为3个阶段你可以暂停,停止,重新启动一个fiber,也可以将优先级更高的操作优先执行,从而来带来更流畅的动画和效率.听起来很hack,他到底是怎么做到的呢?我们试着从源码里面找一下答案.</p>
<h3 id="reconciler"><a href="#reconciler" class="headerlink" title="reconciler"></a>reconciler</h3><p>为了解释fiber就需要提到reconciler,前面已经提到过react允许我们把组件渲染到各种平台和环境中,react可以做到这个的原因就是reconciler,而fiber也是reconciler的一部分,fiber重新定义了reconciler,以浏览器为例:reconciler计算了dom树哪里发生了改变,render在根据发生的改变把他们渲染到不同的平台上面去.</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>前面提到react引入了优先级的概念,scheduler就是根据优先级来调配什么任务需要优先被执行.比如没有在页面中显示的元素他的处理优先级就不应该在一个动画的前面.而在原先的回调堆栈中,回调堆栈只能根据放入堆栈中的执行顺序来依次执行,直到执行到堆栈中没有方法为止.</p>
<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>前面已经提到过fiber可以被认为是stack中的stackFrame,一个组件不论是host组件还是自定义组件同时最多存在两个fiber,正在执行中(workInProgress fiber)的fiber和已经输出的fiber(current fiber),后面解释为什么需要两个fiber,先来看一下fiber的字段.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Fiber = &#123;|</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// fiber的类型 包括有ClassComponent,HostRoot,HostComponent等等</span></span><br><span class="line">  tag: TypeOfWork,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 识别fiber的唯一值</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据类型分配的值 可能是用来实例化组件的方法等等</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个值通常是指向的父级元素,就像Stack Frame返回地址一样</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的值是fiber的子fiber或者兄弟fiber用来遍历subtree来开启任务或者提交任务</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  index: number,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 组件的属性值</span></span><br><span class="line">  pendingProps: any, </span><br><span class="line">  memoizedProps: any, </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新操作的队列</span></span><br><span class="line">  updateQueue: UpdateQueue | <span class="literal">null</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 组件的状态</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 变化类型</span></span><br><span class="line">  effectTag: TypeOfSideEffect,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个受影响的fiber用于提交更新是使用</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">  firstEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">  lastEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的优先级</span></span><br><span class="line">  pendingWorkPriority: PriorityLevel,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//另外一个fiber</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以下面的组件为例来看看fiber是什么样子的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">         <span class="keyword">super</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       render() &#123;</span><br><span class="line">         <span class="keyword">return</span> (</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">             &lt;h3&gt;</span><br><span class="line">              Fiber例子</span><br><span class="line">             &lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">             &lt;div&gt;</span></span><br><span class="line"><span class="regexp">             &lt;/</span>div&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">         );</span></span><br><span class="line"><span class="regexp">       &#125;</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">     ReactDOM.render(</span></span><br><span class="line"><span class="regexp">             &lt;ExampleApplication size="0" /</span>&gt;,</span><br><span class="line">         <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">     );</span><br></pre></td></tr></table></figure></p>
<p>他生成的结构是这样的<br><img src="http://image.jiantuku.com/18-1-15/11117894.jpg?e=1515998410&amp;token=el7kgPgYzpJoB23jrChWJ2gV3HpRl0VCzFn8rKKv:spwyqbyT3s73UGF_ielfxZbfq4E=" alt="react-fiber"><br>而因为是渲染所以他们的优先级都是SynchronousPriority.</p>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>当react开始执行上面这个渲染的时候,会先生成当前container的root-fiber将他传入<code>scheduleUpdate</code>中在这个方法中,在这个方法中主要执行下面几件事:<br>1.如果是有正在执行的任务,并且当前任务优先级高于正在执行的任务,那么将下一个任务清空.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isPerformingWork &amp;&amp; priorityLevel &lt;= nextPriorityLevel) &#123;</span><br><span class="line">      nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.将root-fiber放入Scheduled队列中.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleRoot(root, priorityLevel);</span><br></pre></td></tr></table></figure></p>
<p>3.根据优先级执行<code>performWork</code>方法,如果是比较低优先级的任务那么就安排一个延迟任务,在高级浏览器支持的情况下这里使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener">requestIdleCallback</a>方法他会在浏览器空闲的时候调用函数,不支持的情况也有polyfill.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line"> <span class="keyword">case</span> SynchronousPriority:</span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      performWork(SynchronousPriority, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      performWork(TaskPriority, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (!isCallbackScheduled) &#123;</span><br><span class="line">      scheduleDeferredCallback(performDeferredWork);</span><br><span class="line">      isCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>priorityLevel</code>字段是当前这次操作的优先级等级,这次操作可能是一个setState操作也可能是依次render操作,或是是由<code>unstable_deferredUpdates</code>方法包裹的一个延迟操作方法,像这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.unstable_deferredUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.setState();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></p>
<p> 那么他就会设置一个priorityContext优先级设置为LowPriority的依次操作.在后面通过<code>getPriorityContext</code>方法获取这次操作优先级的使用就会被指定为优先级.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPriorityContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceAsync: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">PriorityLevel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> priorityLevel = priorityContext;</span><br><span class="line">  <span class="keyword">if</span> (priorityLevel === NoWork) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !useSyncScheduling ||</span><br><span class="line">      fiber.internalContextTag &amp; AsyncUpdates ||</span><br><span class="line">      forceAsync</span><br><span class="line">    ) &#123;</span><br><span class="line">      priorityLevel = LowPriority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      priorityLevel = SynchronousPriority;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    priorityLevel === SynchronousPriority &amp;&amp;</span><br><span class="line">    (isPerformingWork || isBatchingUpdates)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> TaskPriority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> priorityLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道了比较关键的priorityLevel字段是哪里来的以后就要看接下来要执行的<code>performWork</code>方法,<br>在这个方法中除了大部分性能监控错误捕捉的代码外(react中有很多while循环的代码,那么在性能监控,调试和错误捕捉上做了大量的工作,有机会的话看看能不能在后面研究一下),<br>1.主要执行了<code>workLoop</code>这个比较重要的方法,而这个方法我认为是类似与回调stack的实现.<br>2.如果<code>workLoop</code>执行完之后还有剩余的任务需要执行那么就再执行<code>requestIdleCallback</code>方法.为什么会有剩余的任务没执行完呢?在看到<code>workLoop</code>方法的时候我们就知道了.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextPriorityLevel &gt; TaskPriority$<span class="number">1</span> &amp;&amp; !isCallbackScheduled) &#123;</span><br><span class="line">      scheduleDeferredCallback(performDeferredWork);</span><br><span class="line">      isCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看<code>workLoop(minPriorityLevel, deadline)</code>之前我们先看一下他的第二个deadline参数,在浏览器空闲执行<code>requestIdleCallback</code>方法的时候,同时会传入一个deadline的参数,<br>通过这个参数调用timeRemaining方法可以获得剩余的空闲时间,那么我们就可以在workLoop执行优先级没那么高的任务时,根据空闲时间来暂停或者继续执行任务了.<br>那接着我们就着重来看一下这个<code>workLoop</code>方法,先看这行代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextUnitOfWork === <span class="literal">null</span>) &#123;</span><br><span class="line">      resetNextUnitOfWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.而在<code>resetNextUnitOfWork</code>方法中做了这几件事:<br>    1.1 清除Scheduled队列中优先级为NoWork的任务.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (</span><br><span class="line">      nextScheduledRoot !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      nextScheduledRoot.current.pendingWorkPriority === NoWork</span><br><span class="line">    ) &#123;</span><br><span class="line">      nextScheduledRoot.isScheduled = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">const</span> next = nextScheduledRoot.nextScheduledRoot;</span><br><span class="line">      nextScheduledRoot.nextScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (nextScheduledRoot === lastScheduledRoot) &#123;</span><br><span class="line">        nextScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">        lastScheduledRoot = <span class="literal">null</span>;</span><br><span class="line">        nextPriorityLevel = NoWork;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      nextScheduledRoot = next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>1.2 找到优先级别最高的任务,设置为下一个要开始的任务.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (</span><br><span class="line">       root.current.pendingWorkPriority !== NoWork &amp;&amp;</span><br><span class="line">       (highestPriorityLevel === NoWork ||</span><br><span class="line">         highestPriorityLevel &gt; root.current.pendingWorkPriority)</span><br><span class="line">     )  &#123;</span><br><span class="line">       highestPriorityLevel = root.current.pendingWorkPriority;</span><br><span class="line">       highestPriorityRoot = root;</span><br><span class="line">     &#125;</span><br><span class="line">     root = root.nextScheduledRoot;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (highestPriorityRoot !== <span class="literal">null</span>) &#123;</span><br><span class="line">     nextPriorityLevel = highestPriorityLevel;</span><br><span class="line">     resetContextStack();</span><br><span class="line"></span><br><span class="line">     nextUnitOfWork = createWorkInProgress(</span><br><span class="line">       highestPriorityRoot.current,</span><br><span class="line">       highestPriorityLevel,</span><br><span class="line">     );</span><br><span class="line">     <span class="keyword">if</span> (highestPriorityRoot !== nextRenderedTree) &#123;</span><br><span class="line">       nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">       nextRenderedTree = highestPriorityRoot;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>nextUnitOfWork === null</code>,我们之前在<code>scheduleUpdate</code>所做的事的第一点中提到过如果有正在执行的任务,并且当前任务优先级高于正在执行的任务nextUnitOfWork会被置空,那么到了这里正在执行的低优先级的任务就被暂停了,然后重新找到优先级最高的任务重新作为下一个任务.也就是fiber被暂停,并开始优先级高的任务.<br>找到优先级最高的任务之后就开始循环执行了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">loop: <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextPriorityLevel &lt;= TaskPriority) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">          <span class="keyword">if</span> (nextUnitOfWork === <span class="literal">null</span>) &#123;</span><br><span class="line">            priorityContext = TaskPriority;</span><br><span class="line">            commitAllWork(pendingCommit);</span><br><span class="line">            priorityContext = nextPriorityLevel;</span><br><span class="line">            handleCommitPhaseErrors();</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              nextPriorityLevel === NoWork ||</span><br><span class="line">              nextPriorityLevel &gt; minPriorityLevel ||</span><br><span class="line">              nextPriorityLevel &gt; TaskPriority</span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deadline !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span> &amp;&amp; !deadlineHasExpired) &#123;</span><br><span class="line">          <span class="keyword">if</span> (deadline.timeRemaining() &gt; timeHeuristicForUnitOfWork) &#123;</span><br><span class="line">            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">            <span class="keyword">if</span> (nextUnitOfWork === <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (deadline.timeRemaining() &gt; timeHeuristicForUnitOfWork) &#123;</span><br><span class="line">                priorityContext = TaskPriority;</span><br><span class="line">                commitAllWork(pendingCommit);</span><br><span class="line">                priorityContext = nextPriorityLevel;</span><br><span class="line">                handleCommitPhaseErrors();</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                  nextPriorityLevel === NoWork ||</span><br><span class="line">                  nextPriorityLevel &gt; minPriorityLevel ||</span><br><span class="line">                  nextPriorityLevel &lt; HighPriority</span><br><span class="line">                ) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deadlineHasExpired = <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deadlineHasExpired = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (nextPriorityLevel) &#123;</span><br><span class="line">        <span class="keyword">case</span> SynchronousPriority:</span><br><span class="line">        <span class="keyword">case</span> TaskPriority:</span><br><span class="line">          <span class="keyword">if</span> (nextPriorityLevel &lt;= minPriorityLevel) &#123;</span><br><span class="line">            <span class="keyword">continue</span> loop;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> loop;</span><br><span class="line">        <span class="keyword">case</span> HighPriority:</span><br><span class="line">        <span class="keyword">case</span> LowPriority:</span><br><span class="line">        <span class="keyword">case</span> OffscreenPriority:</span><br><span class="line">          <span class="keyword">if</span> (deadline === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> loop;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!deadlineHasExpired &amp;&amp; nextPriorityLevel &lt;= minPriorityLevel) &#123;</span><br><span class="line">            <span class="keyword">continue</span> loop;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span> loop;</span><br><span class="line">        <span class="keyword">case</span> NoWork:</span><br><span class="line">          <span class="keyword">break</span> loop;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个循环中主要分为两种情况:<br>1.优先级为TaskPriority和SynchronousPriority的任务,也就是马上要执行的任务,那他就会立马调用<code>performUnitOfWork</code>执行.<br>2.剩下就作为延迟任务,前面已经提到过<code>deadline.timeRemaining()</code>可以获得还剩多少空闲时间来执行任务,那么在空闲时间足够的情况下就可以执行<code>performUnitOfWork</code>方法了.<br>在<code>performUnitOfWork</code>方法中主要是执行两个方法:<br>1.beginWork开始一个fiber任务,给当前执行的fiber的component进行实例化调用实例的render方法,调用<code>shouldComponentUpdate</code>比较前后state和prop差异,然后生成然后返回他的child fiber,如果没有child fiber则返回一个null.<br>2.在没有child fiber的情况下执行<code>completeUnitOfWork</code>,在<code>completeUnitOfWork</code>中执行<code>prepareUpdate</code>比较fiber的diff,如果存在diff加入到update队列中,标记影响顺序.然后在有兄弟节点的情况下返回兄弟fiber,在没有兄弟fiber的情况下一直向上向父级继续执行completeUnitOfWork.<br>最后在fiber为root fiber的时候将pendingCommit赋值为root fiber在下一次任务开始的时候就会进入到<code>commitAllWork</code>阶段了,在<code>commitAllWork</code>方法中就直接提交差异将子fiber节点加入到父fiber节点中了.</p>
<p>到这里可以看到 一个fiber更新 将经历下面几个阶段<br>1.beginWork:           创建实例,比较state对象差异.<br>2.completeUnitOfWork:  调用<code>prepareUpdate</code>比较fiber diff,标记side affect,加入update队列.<br>3.commitAllWork:       提交差异更新节点.<br>其中对于延迟任务来说,在第1和第2个阶段可以被打断,在第三个阶段会一次性提交所有差异,且无法打断.<br>相反对于高优先级别的任务比较简单,会连贯的完成三个阶段.<br>一个fiber树在渲染的时候三个阶段的顺序如图<br><img src="http://image.jiantuku.com/18-1-16/51726724.jpg?e=1516086010&amp;token=el7kgPgYzpJoB23jrChWJ2gV3HpRl0VCzFn8rKKv:tQWcGjlBexVCSyT_tG7FS99PmRU=" alt="react-fiber阶段执行顺序"><br>前面提到一个组件最多存在两个fiber,fiber的alternate字段指向各自的另外一个fiber,也就是说current fiber的alternate是work-In-Progress Fiber,而work-In-Progress Fiber的alternate指向current fiber.一个fiber在经历三个阶段的时候,在最后的一个阶段才会提交改动,workInProgress fiber的存在是不希望在前两个阶段计算差异的时候去改变dom,而能够在最后一个阶段一次性提交改动,react在这里使用了双缓存池技术,因为在一个组件最多由两个fiber的情况下,缓存一个fiber可以重用和避免分配内存是带来的开销.</p>
<p>最后用<a href="https://github.com/claudiopro/react-fiber-vs-stack-demo" target="_blank" rel="noopener">https://github.com/claudiopro/react-fiber-vs-stack-demo</a>来梳理一下fiber是如何schedule任务的.<br>首先看到这个demo中的这段代码.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOMFiber.render(</span><br><span class="line">    &lt;ExampleApplication elapsed=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start&#125; /&gt;,    <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">  );</span><br><span class="line">  requestAnimationFrame(update);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(update);</span><br></pre></td></tr></table></figure></p>
<p>他定义了一个递归任务,在每一帧里更新ExampleApplication的elapsed属性,让图形最后得到一个动画的效果.这里的每次<code>render</code>方法都是一个最高级别SynchronousPriority级别优先级的任务.<br>接着看到tick方法中定义了一个延迟操作,他会在每一秒钟更新seconds的值,因为他是一个延迟的操作,也就是说这个setState操作的优先级是LowPriority的.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> componentDidMount() &#123;</span><br><span class="line">          <span class="keyword">this</span>.intervalID = setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">tick() &#123;</span><br><span class="line">          ReactDOMFiber.unstable_deferredUpdates(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">seconds</span>: (state.seconds % <span class="number">10</span>) + <span class="number">1</span> &#125;))</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Stack的版本中所有的操作都依次的加入到回调stack中被依次调用,画面出现了卡顿,托帧的效果.<br>相反的在fiber的版本的因为有了优先级的存在.低优先级的任务会在浏览器渲染空闲回调时间允许的时间里执行,没有出现卡顿,得到一个流畅的效果,虽然seconds没有被及时的更新但是我们认为一个低优先的任务被延迟是没关系的.让我们想象一下:<br>现在<code>render</code>正在更新<code>elapsed</code>属性,fiber树立刻开始执行在没有延迟的情况下执行完了三个阶段,并且提交了渲染结果.在requestAnimationFrame的不停调用下这个方法也在不停的被执行.<br>这是延迟操作setState被执行了,因为是一个LowPriority的操作,这个操作将在浏览器空闲的时候被调用.<br>这个时候浏览器空闲了,开始执行第一个fiber的beginWork操作返回了一个child作为下一个任务.正在准备执行下一个任务的时候发现空闲时间已经不足了也就是说<code>deadline.timeRemaining() &gt; timeHeuristicForUnitOfWork = false;</code>.浏览器又接受到了新的render方法的更新值.<br>这时<code>scheduleUpdate</code>中的<code>if (!isPerformingWork &amp;&amp; priorityLevel &lt;= nextPriorityLevel)</code>成立<code>nextUnitOfWork = null;</code>下次<code>resetNextUnitOfWork</code>又重新找到了现在优先级最高的<code>render</code>操作开始执行<code>render</code>.<br>等浏览器又有空闲的时候之前没有结束的<code>setState</code>操作又被执行,<strong>之前执行过的fiber他的priority已经为NoWork然后被跳过</strong>,直接达到没有上次被暂停的任务开始继续执行,就这样好几个空闲时间之后一次<code>setState</code>操作终于走完前面两个阶段获得了diff终于可以在空闲的时间执行了commit操作提交了diff.至此完成的<code>setState</code>完成也没有影响<code>render</code>动画.</p>
<p>react fiber的初探暂时就到这里,关于这个版本的react有很多新的东西可以展开,比如错误绑定,性能监控,开发调试.另外也可以定义自己的Custom Renderer.可以学到很多东西,也希望有兴趣的朋友一起交流指出,谢谢!</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/01/12/react-fiber源码学习1/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-译-Single-page-application-on-wikipedia" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/03/译-Single-page-application-on-wikipedia/">(译)Single-page application on wikipedia</a>
    </h1>
  

        
        <a href="/2017/08/03/译-Single-page-application-on-wikipedia/" class="archive-article-date">
  	<time datetime="2017-08-03T13:15:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-08-03</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h1><p>单页应用 (SPA)是一个提供了类似于桌面应用程序相似用户体验而全站只有一个页面的网站应用或者网站站点。在一个SPA中,所有需要的代码-HTML,JavaScript,和CSS-在单页面加载时取得，或者在需要的时候会动态加载合适的资源增加到页面中，这一般都是根据用户的操作来相应的。页面不会在过程中的任何时间重新加载，尽管location hash和HTML5 History API可以被用于给程序中的分开逻辑页面提供导航的能力但是他也不会把控制权转交给任何一个其他页面。单页应用通常会在应用背后动态的跟web服务器进行数据交换(数据传输)。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>单页应用短语的由来是不清楚的，这个概念早在2003年就被开始讨论。Stuart Morris在2004年4月的时候在slashdotslash.com上编写了独立页面来描述什么是单页应用,在同一年的稍晚些时候Lucas Birdeau, Kevin Hakman, Michael Peachey 和 Evan Yeh就在美国专利8,136,109描述了单页应用的应用.</p>
<p>JavaScript可以在web浏览器上使用展示用户UI,运行应用逻辑，然后和web服务器进行数据交换。成熟的开源库可以有效的为构建一个单页应用提供支持，开发人员也可以减少大量的JavaScript编写工作。</p>
<h2 id="技术途径"><a href="#技术途径" class="headerlink" title="技术途径"></a>技术途径</h2><p>有各种技术使浏览器即使是当应用需要和服务器进行通讯的时候也能够维持一个单页应用。</p>
<h3 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h3><p>web浏览器框架类似 AngularJS, Ember.js, Meteor.js, ExtJS 和 React 都是兼容SPA原则的。</p>
<ul>
<li>AngularJS完全是一个客户端的框架。AngularJS的模板是基于双向数据绑定的。数据绑定是一个当model改变的时候自动更新视图的方式，当视图发生改变的时候他同样的也会更新model。HTML模板在浏览器中被编译。编译阶段创建纯净的HTML，浏览器会重新渲染这些HTML到现有的视图中。这个阶段会在后续的页面视图重复。在传统的服务器端HTML程序中，类似控制器和model的概念结合生产出新的HTML视图。在AngularJS框架中，控制器和model的状态在客户端浏览器中维护。因此，新页面可以在没有任何服务器参与的情况下被生成。</li>
<li>Ember.js是一个客户端JavaScript web应用框架，他是基于model-视图-控制(MVC)软件架构模式的框架。他允许开发者通过可混合的风格和富对象,声明双向数据绑定,计算属性和Handlebars.js提供的自动更新模板能力,管理应用路由状态这些框架最佳实践模式来创建可伸缩的单页应用。</li>
<li>Meteor.js是一个全栈(客户端到服务端)JavaScript框架他是专门为SPA设计的。他的数据绑定比Angular,Ember 或者 ReactJS更简单,他使用分布式数据协议(Distributed Data Protocol)和发布订阅模式来在不需要开发者写任何同步代码的情况下实时自动传播数据改变给客户端。全栈响应确保了所有层面,从数据库到模板，可以在需要的时候自动更新他们自己。Ecosystem系统类似于服务端渲染它解决了搜索引擎优化的问题。</li>
<li>Aurelia是一个手机端,桌面端,浏览器端JavaScript框架。他和AngularJS相似,但是更新,更符合标准,采用了模块化的方式。Aurelia使用下一代ECMAScript书写。</li>
<li>Vue.js 是一个开源JavaScript框架他用来构建用户界面。结合cli和webpack我们可以更简单的创建SPA。</li>
</ul>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>使用最多的技术现在是Ajax。占主导地位的是使用JavaScript中的XMLHttpRequest/ActiveX Object(不赞成)对象，其他Ajax方式包括IFRAME或者script HTML元素。像jQuery这类流行的库,他在不同浏览器中标准化Ajax的行为,这使Ajax更受欢迎。</p>
<h4 id="Websockets"><a href="#Websockets" class="headerlink" title="Websockets"></a>Websockets</h4><p>Websockets是客户端和服务端双向实时状态通讯技术是HTML规范的其中一部分。Ajax的升级版,比Ajax更高效更简单。</p>
<h4 id="Server-sent-events"><a href="#Server-sent-events" class="headerlink" title="Server-sent events"></a>Server-sent events</h4><p>服务器推送事件(SSEs)是一个借由以服务器开始传入数据到浏览器客户端的技术。一旦一个初始化连接被建立，一个事件流会保持打开直到浏览器关闭。SSEs通过传统HTTP发送,有各种特性可以弥补Websockets设计上的缺陷，分别是自动重新连接，事件ID，和任意传入事件的能力。</p>
<h4 id="Browser-plugins"><a href="#Browser-plugins" class="headerlink" title="Browser plugins"></a>Browser plugins</h4><p>尽管这个方法已经过期，异步调用服务同样可以使用类似Silverlight, Flash, 或者 Java applets这些浏览器插件来达到目的。</p>
<h4 id="Data-transport-XML-JSON-and-Ajax"><a href="#Data-transport-XML-JSON-and-Ajax" class="headerlink" title="Data transport (XML, JSON and Ajax)"></a>Data transport (XML, JSON and Ajax)</h4><p>请求服务器通常是请求原始数据(XML或者JSON,等等),或者是返回新的HTML。当服务器返回HTML时,客户端的JavaScript会更新部分区域的DOM。当原始数据返回时,通常客户端的JavaScript会处理XML/(XSL)(还有JSON模板)用这些原始数据转换成为HTML,用来更新部分区域的DOM。</p>
<h2 id="服务端架构"><a href="#服务端架构" class="headerlink" title="服务端架构"></a>服务端架构</h2><h3 id="Thin-server-architecture"><a href="#Thin-server-architecture" class="headerlink" title="Thin server architecture"></a>Thin server architecture</h3><p>一个单页面应用面把逻辑从服务端转移到客户端。他的结果就是web服务端的角色进化成为一个纯净的数据API服务或者提供web服务。这个架构的转变，在一些圈子中被成为”瘦服务端架构”他强调把复杂从服务端转移到客户端，最终减低了系统的整体复杂度。</p>
<h3 id="Thick-stateful-server-architecture"><a href="#Thick-stateful-server-architecture" class="headerlink" title="Thick stateful server architecture"></a>Thick stateful server architecture</h3><p>服务器会在内存中保存需要的客户端页面的状态。通过这种方式，当任何请求到达服务端(通常是用户操作),服务端根据客户端具体的改变和希望达到的状态发送对应的HTML和/或者JavaScript(通常是增加/删除/更新一部分客户端的DOM)。同时，服务端的对应状态会更新。大多数的逻辑在服务端运行，通常HTML也会在服务端渲染。某种程度上来说，服务端充当一个web浏览器，接受事件和在服务端处理状态改变自动传播给客户端。这个方式需要更多的内存和服务器处理，但是优势是简单的开发模式因为 a)通常应用的大部分代码在客户端 b)数据和UI状态在服务端共享同一片内存空间这就不需要服务端和客户端建立通讯桥梁。</p>
<h3 id="Thick-stateless-server-architecture"><a href="#Thick-stateless-server-architecture" class="headerlink" title="Thick stateless server architecture"></a>Thick stateless server architecture</h3><p>这是富状态服务器的变种。客户端页面通常通过Ajax请求发送数据给服务端用来代表自身的状态。通过数据，服务端就可以重新构建客户端需要修改的部分页面的状态和生成必要的数据或者代码(JSON或者JavaScript)，返回给客户端新的状态,通常是根据对应的请求和客户端操作修改页面的DOM。</p>
<p>这个方式传送更多的数据给服务器和每个请求需要更多的计算资源来在服务端部分或者全部重新构建客户端页面的状态。同时，这个方式可以更简单的升级因为在服务端没有每一个客户端的页面数据保存，因此，Ajax请求可以在不需要同域数据共享或者服务器关联的情况下可以发送给不同的服务器。</p>
<h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>一些单页应用程序也许会使用文件URL方案从一个本地文件被执行。这给了用户从一个在不依赖和服务器链接的情况下从服务器下载单页应用程序然后从本地存储中运行单页应用程序文件的能力。如果这类单页应用程序像保存和更新数据，这必须使用以浏览器为基础的Web存储。这些程序都是得益于HTML5的使用。</p>
<h2 id="单页应用程序的挑战"><a href="#单页应用程序的挑战" class="headerlink" title="单页应用程序的挑战"></a>单页应用程序的挑战</h2><p>因为单页应用程序是从无状态页面渲染模式进化而来的，而浏览器也是根据这个模式设计的，那么一些新的挑战也就出现了。这些问题每个都由一个有效的解决方案:</p>
<ul>
<li>客户端JavaScript库处理各种问题。</li>
<li>针对单页应用模式专门的服务端web框架。</li>
<li>浏览器的进化和专门为单页应用模式设计的HTML5 API。</li>
</ul>
<h3 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h3><p>因为一些流行的Web搜索引擎爬虫对JavaScript执行的缺乏，SEO(搜索引擎优化)有从公开web站点转变成单页应用模式而带来的历史遗留问题。</p>
<p>在2009到2015年之间，谷歌web管理中心提议和推荐一个”AJAX爬虫模式”在片段中使用一个惊叹号标志标识一个带状态的AJAX页面 (#!)。这个特指行为应用在单页应用程序上允许搜索引擎爬虫提取相关的原始数据。对于那些不支持URL hash的引擎,SPA的URL hash将被视而不见。这些”hash URL”被那些包括W3C中的Jeni Tennison的一些人认为是一个问题因为他让那些没有激活JavaScript的浏览器无法访问。他也打破了浏览器HTTP头部引用不允许在引用头部发送部分标识符的约束。在2015年,Google取消了Ajax hash爆炸的提议。</p>
<p>另外，应用需要在服务器渲染第一个页面然后随后的页面在客户端更新。这在传统上比较困难的，因为渲染代码可能需要在服务端和客户端用不同的语言或者框架书写。使用无逻辑的模板,跨语言的编译，或者在服务端或者客户端使用同样的语言获取可以使大量的代码得到共享。</p>
<p>因为SEO在SPA中不能很好兼容，值得注意的在需要搜索引擎抓取的页面通常是使用SAP的。使用场景包括隐藏在权限系统背后表面私有数据的应用程序。在应用程序电子商务的场景下，通常是经典的”页面重绘”模式是在应用的着陆页和营销网站，他们提供的原始数据作为搜索引擎搜索显示的点。博客，论坛和其他的传统页面手工重绘通常可以给搜索引擎发送相关的点。</p>
<p>其他的方式是使用服务器为中心的web框架比如基于Java的ItsNat他在服务端使用同一个语言和模板技术渲染任何一个超文本。在这个方式中，服务端可以精确的知道客户端Dom的状态，任何大或者小的页面更新都需要服务器生成，然后通过Ajax传输，Javascript代码会给客户端页面带来新的状态执行DOM方法。开发者可以决定哪个页面状态可以被web蜘蛛爬取作为SEO和在加载时根据状态生成纯HTML而不是Javascript。在ItsNat框架的场景下，这是自动的因为ItsNat在服务端保存客户端的DOM树作为一个Java W3C树;在加载时为Ajax请求在服务端渲染Dom树生成纯HTML和Javascript DOM操作。这对SEO是非常重要的因为开发者可以在服务端用相同的Java代码基于纯净的HTML的模板构建得到想要的DOM。在页面加载时间，转换HTML的生成是ItsNat根据DOM的状态做的SEO兼容。在1.3版本,ItsNat提供了一个新的无状态模式，客户端的DOM不在保存在服务端因为和无状态模式客户端，当客户端发送的任何Ajax请求数据通知当前DOM的状态这些DOM状态部分或者全部在服务端重新构建；无状态模式可能仍然是SEO兼容的因为SEO兼容性发生在初始页面的加载时间这不受有状态或者无状态模式的影响。</p>
<p>有几个解决方案让web站点看起来是可爬的。他们都涉及创建独立的HTML页面倒影SPA的内容。服务端可以创建基于HTML版本的站点然后传送他们使他们可爬，或者使用没有界面的浏览器类似PhantomJS来运行<br>JavaScript应用输出HTML结果。</p>
<p>这些都需要不少的努力，最终可以结束大型复杂站点的维护噩梦。他们也仍然有SEO潜在陷阱。如果服务端生成的HTML被认为和SPA内容不同，那么对站点将会不利。运行PhantomJS输出HTML可以减慢页面响应的速度，这会导致搜索引擎，特别是Google搜索引擎的排名降级。</p>
<h2 id="客户端-服务器代码分离"><a href="#客户端-服务器代码分离" class="headerlink" title="客户端/服务器代码分离"></a>客户端/服务器代码分离</h2><p>使服务端和客户端的代码可以大量的共享的一种方式是使用无逻辑的模板语言类似Mustache或者Handlebars。这类模板可以从不同的宿主语言渲染，类似服务端使用Ruby客户端使用Javascript。然而，仅仅使用共享模板通常需要使用重复的业务逻辑用正确的模板和数据去填充他们。当只需要更新一小部分的页面时从模板渲染可能会给性能带来负面的影响-类似从一个很大的模板上更新一个input的文本。不是仅仅更新改变的位置，替换整个模板可能仍然会影响用户选择和鼠标位置。为了避免这些问题，应用可以使用UI数据绑定或者只更新页面合适的位置而不是重新渲染整个模板的方式。</p>
<h2 id="浏览器历史记录"><a href="#浏览器历史记录" class="headerlink" title="浏览器历史记录"></a>浏览器历史记录</h2><p>根据SPA的定义”单页面应用”，这个模式打破了浏览器为页面设计的前进/后退导航按钮。这表示当用户点击后退按钮时将会没用,单页面卸载之后浏览器历史记录了前面的记录，而不是SAP中前面屏幕的状态。</p>
<p>传统的解决方法是SPA需要修改浏览器URL的hash来标识当前屏幕的状态。这可以通过Javascript达到，然后使URL历史记录事件在浏览器中构建。一旦SPA有能力在同一个屏幕通过URL hash拯救，期望的后退按钮就回来了。</p>
<p>未来解决这个问题，HTML5专门介绍了pushState和replaceState提供了让程序读取真正的URL和浏览器历史记录。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>类似Google分析的分析工具大量依赖在浏览器中整个新页面的加载,根据新页面加载初始化。SPA不是这样工作的。</p>
<p>第一个页面加载之后，所有随后的页面和内容修改由应用内部处理，这应该简单的调用一个方法去更新分析工具。不能调用这个方法，浏览器不会触发新页面的加载，浏览器记录中也不会增加任何东西，分析工具将没办法知道谁在站点上干了什么。</p>
<h2 id="SPA中增加页面加载"><a href="#SPA中增加页面加载" class="headerlink" title="SPA中增加页面加载"></a>SPA中增加页面加载</h2><p>使用HTML5历史API在SPA中增加页面加载事件是可能的;这将帮助整合分析工具。难度主要来自于管理和确保全部东西都被正确跟踪-这牵涉了检查丢失报告和双入口。一些框架提供开源分析工具整合解决这些问题。开发者可以不必从头做起只需要整合他们到你的应用程序来确保一切都正确工作。</p>
<h2 id="初始化加载的速度"><a href="#初始化加载的速度" class="headerlink" title="初始化加载的速度"></a>初始化加载的速度</h2><p>单页面应用程序比基于服务器的应用程序第一个页面的加载速度要更慢。这是因为第一次加载需要在浏览器在渲染需要的view之前把框架和应用程序代码取下来。一个基于服务器的应用程序只需要把HTML发送给浏览器，减少延迟和下载时间。</p>
<h2 id="增加页面加载速度"><a href="#增加页面加载速度" class="headerlink" title="增加页面加载速度"></a>增加页面加载速度</h2><p>增加SPA初始化加载速度有几种办法，类似缓存方式和当需要的时候懒加载模块。但是不可避免的需要下载框架，至少是一部分的应用代码，然后将会在浏览器显示东西之前调用API请求数据。这是一个”现在就付钱，和等下付钱的”讨价还价的剧情。性能和等候时间的决定是开发者必须做出的。</p>
<h2 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h2><p>一个SPA是完全在初始加载页面阶段加载然后页面区域根据需求从服务端替换或者更新新的页面。为了避免下载未使用的特性，SPA将会逐渐下载他们需要的更多特性，不论是小部分的页面，还是用来组成屏幕上的模块。</p>
<p>这样就存在一个SPA中的”状态”和传统网站中的”页面”的比较，因为”状态导航”在类似于页面导航，理论上，任何基于页面的web站点可以通过替换统一页面转换为单页面程序只需要修改和比较非SPA的结果就可以。</p>
<p>在web上SPA方式类似于原始桌面程序流行的单文档接口(SDI)技术。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/08/03/译-Single-page-application-on-wikipedia/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-vue源代码学习-vue的响应模块" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/vue源代码学习-vue的响应模块/">vue源代码学习-vue的响应式系统模块</a>
    </h1>
  

        
        <a href="/2017/07/29/vue源代码学习-vue的响应模块/" class="archive-article-date">
  	<time datetime="2017-07-29T04:30:59.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是响应式系统"><a href="#什么是响应式系统" class="headerlink" title="什么是响应式系统"></a>什么是响应式系统</h3><p>我们之前已经了解了Virtual Dom是怎么一回事，而在vue和其他前端框架中都有一个很重要的概念就是响应式系统，不论是使用脏检查,依赖收集,还是其他方式都是为了一个目的，就是在数据发生变化的时候通知<br>所相关的组件进行更新,那么我们来看看在vue中,这个模块是如何工作的。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>在我们了解vue的响应式系统之前我们先要了解一下Object.defineProperty,他是ES5.1 规范中提出的,我们可以通过他来定义(劫持)对象的读取和写入方法,像这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(_object, <span class="string">'p'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>() &#123;          </span><br><span class="line">   ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(newValue) &#123;   </span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">他的中文介绍在这里[MDN-Object.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。</span></span><br><span class="line"><span class="string">而在vue的响应系统中就用到这个方法,这也是他不支持IE8及以下版本浏览器的原因。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### vue中的响应系统</span></span><br><span class="line"><span class="string">我们了解了Object.defineProperty之后还要搞清楚一个关系,在vue中响应模块主要依赖三个部分展开的,他们分别是Observer,Dep,watcher.</span></span><br><span class="line"><span class="string">Observer:负责监控属性变化。</span></span><br><span class="line"><span class="string">Dep:负责收集管理观察者。</span></span><br><span class="line"><span class="string">watcher:观察者,响应变化。</span></span><br><span class="line"><span class="string">他们三个的关系是这样的:</span></span><br><span class="line"><span class="string">![](http://image.jiantuku.com/17-7-29/79326618.jpg?attname=file_1501311348782_15964.png&amp;e=1501311610&amp;token=el7kgPgYzpJoB23jrChWJ2gV3HpRl0VCzFn8rKKv:MUaLIpJNPAcSZAjbXIwQgU8M-b8=)</span></span><br><span class="line"><span class="string">在来看一下Observer:</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> JavaScript</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而defineReactive方法就是使用了Object.defineProperty劫持属性get/set的方法了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          dependArray(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">当每个属性调用defineReactive方法的时候，每个属性都有各自的Dep对象，他们收集了依赖这个属性的watcher对象，当对象set数据发生改变的时候，调用对应dep对象的notify通知他们发生改变。</span></span><br><span class="line"><span class="string">另外他们还共享同一个Dep对象的target,他存储了当前的watcher对象。来看我们之前熟悉的一段代码`</span>vm._watcher = <span class="keyword">new</span> Watcher(vm, updateComponent, noop)<span class="string">`。另外结合wathcer对象的构造函数(wathcer对象同时也用于$watch方法)。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> JavaScript</span><br><span class="line"> <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid</span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy </span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//当expOrFn为非function对象,则返回用于获取vm对象属性的方法。</span></span><br><span class="line">    <span class="comment">//例如:expOrFn：'a'    则返回用于获得vm.a对象属性的方法</span></span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)                                                                      </span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ------------------------------<span class="keyword">get</span>方法------------------------</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="comment">//设置当前Dep.target对象为目前的watcher。</span></span><br><span class="line">      pushTarget(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">let</span> value</span><br><span class="line">      <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用之前的expOrFn方法获取返回值</span></span><br><span class="line">        <span class="comment">//如果是updateComponent或者其他获取对象的方法,</span></span><br><span class="line">        <span class="comment">//势必可能会依赖别的属性来生成视图或者对象。那么就会调用对应依赖属性的get方法</span></span><br><span class="line">        <span class="comment">//这个时候当前的Dep.target对象已经指向当前的watcher</span></span><br><span class="line">        <span class="comment">//而当前watcher对象将会被加入到其依赖属性的dep对象中。在这个属性发生改变时通知watcher</span></span><br><span class="line">        value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 深度依赖收集，</span></span><br><span class="line">        <span class="comment">// 深层级的对象如:a.b.c.e。设置deep选项就逐级收集watcher对象到当前Dep.target</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">          traverse(value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//弹出当前target</span></span><br><span class="line">        popTarget()</span><br><span class="line">        <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>借用一下<a href="https://github.com/jin5354/404forest/issues/60" target="_blank" rel="noopener">https://github.com/jin5354/404forest/issues/60</a>中的图:<img src="https://camo.githubusercontent.com/b76d07b52d5b7c6b313663ef3a06906a04c96acb/68747470733a2f2f7777772e343034666f726573742e636f6d2f696d67732f626c6f672f726561637469766974792d73797374656d2d332e706e67" alt><br>那么这里依赖就收集完毕了。当属性发生改变时在set方法中就会执行对应的<code>dep.notify()</code>方法通知依赖这个属性的watcher进行update。而update方法是这样的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">//如果是懒更新则标记为脏数据，表示数据已经发生改变，在计算数据的时候获得最新值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">//异步更新直接调用run方法</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则加入watcher队列</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>queueWatcher(this)</code>中方法会调用<code>nextTick(flushSchedulerQueue)</code>，在这个方法里有一些兼容性代码,判断当前平台是否支持Promise或者MutationObserver如果都不支持的话则调用<code>setTimeout(nextTickHandler, 0)</code>setTimeout 0原理和干了什么可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">这里</a><br>下面附上flushSchedulerQueue方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//调用watcher update</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在watcher.run中就会调用getter方法获取最新的值(重新渲染组件),，并且调用值发生变化以后的回调函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">//调用get获得最新的值</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/29/vue源代码学习-vue的响应模块/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-You-Don-t-Know-JS-this-Object-Prototypes-Chapter-2-this-All-Makes-Sense-Now" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/You-Don-t-Know-JS-this-Object-Prototypes-Chapter-2-this-All-Makes-Sense-Now/">You Don&#39;t Know JS: this &amp; Object Prototypes-Chapter 2: this All Makes Sense Now</a>
    </h1>
  

        
        <a href="/2017/07/29/You-Don-t-Know-JS-this-Object-Prototypes-Chapter-2-this-All-Makes-Sense-Now/" class="archive-article-date">
  	<time datetime="2017-07-29T04:19:26.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="You-Don’t-Know-JS-this-amp-Object-Prototypes"><a href="#You-Don’t-Know-JS-this-amp-Object-Prototypes" class="headerlink" title="You Don’t Know JS: this &amp; Object Prototypes"></a>You Don’t Know JS: <em>this</em> &amp; Object Prototypes</h1><h1 id="Chapter-2-this-All-Makes-Sense-Now"><a href="#Chapter-2-this-All-Makes-Sense-Now" class="headerlink" title="Chapter 2: this All Makes Sense Now!"></a>Chapter 2: <code>this</code> All Makes Sense Now!</h1><h1 id="你不知道的JS-this-amp-对象原型"><a href="#你不知道的JS-this-amp-对象原型" class="headerlink" title="你不知道的JS:this &amp; 对象原型"></a>你不知道的JS:<em>this</em> &amp; 对象原型</h1><h1 id="第二章-现在this的一切都有了意义"><a href="#第二章-现在this的一切都有了意义" class="headerlink" title="第二章:现在this的一切都有了意义"></a>第二章:现在<code>this</code>的一切都有了意义</h1><p>In Chapter 1, we discarded various misconceptions about <code>this</code> and learned instead that <code>this</code> is a binding made for each function invocation, based entirely on its <strong>call-site</strong> (how the function is called).</p>
<p>在第一章中，我们抛弃了各种有关<code>this</code>的错误的观点，然后学习了<code>this</code>其实是一个为每个方法执行进行的一个绑定，完全以<strong>调用位置</strong>为基础(方法如何被调用)。</p>
<h2 id="Call-site"><a href="#Call-site" class="headerlink" title="Call-site"></a>Call-site</h2><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>To understand <code>this</code> binding, we have to understand the call-site: the location in code where a function is called (<strong>not where it’s declared</strong>). We must inspect the call-site to answer the question: what’s <em>this</em> <code>this</code> a reference to?</p>
<p>为了理解<code>this</code>绑定，我们需要了解调用位置:在代码中一个方法被调用的位置(<strong>不是他在哪里声明</strong>)。我们必须检查调用位置来回答这个问题:这个<code>this</code>引用着什么?</p>
<p>Finding the call-site is generally: “go locate where a function is called from”, but it’s not always that easy, as certain coding patterns can obscure the <em>true</em> call-site.</p>
<p>通常找到调用位置是:”到一个方法从哪里被调用的位置”，但是这不是每次都那么简单，例如某一种代码模式会混淆<em>真正</em>的调用位置。</p>
<p>What’s important is to think about the <strong>call-stack</strong> (the stack of functions that have been called to get us to the current moment in execution). The call-site we care about is <em>in</em> the invocation <em>before</em> the currently executing function.</p>
<p>重要的是要考虑<strong>调用堆栈</strong>(方法调用的堆栈使我们能到达当前执行的瞬间)。调用位置我们关心的是在我们当前执行方法之前的调用。</p>
<p>Let’s demonstrate call-stack and call-site:</p>
<p>让我们来演示调用堆栈和调用位置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call-stack is: `baz`</span></span><br><span class="line">    <span class="comment">// so, our call-site is in the global scope</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"baz"</span> );</span><br><span class="line">    bar(); <span class="comment">// &lt;-- call-site for `bar`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call-stack is: `baz` -&gt; `bar`</span></span><br><span class="line">    <span class="comment">// so, our call-site is in `baz`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</span><br><span class="line">    foo(); <span class="comment">// &lt;-- call-site for `foo`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call-stack is: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class="line">    <span class="comment">// so, our call-site is in `bar`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// &lt;-- call-site for `baz`</span></span><br></pre></td></tr></table></figure>
<p>Take care when analyzing code to find the actual call-site (from the call-stack), because it’s the only thing that matters for <code>this</code> binding.</p>
<p>当分析代码来寻找真正的调用位置时(从调用堆栈里)需要小心，因为这个是<code>this</code>绑定唯一在意的事情。</p>
<p><strong>Note:</strong> You can visualize a call-stack in your mind by looking at the chain of function calls in order, as we did with the comments in the above snippet. But this is painstaking and error-prone. Another way of seeing the call-stack is using a debugger tool in your browser. Most modern desktop browsers have built-in developer tools, which includes a JS debugger. In the above snippet, you could have set a breakpoint in the tools for the first line of the <code>foo()</code> function, or simply inserted the <code>debugger;</code> statement on that first line. When you run the page, the debugger will pause at this location, and will show you a list of the functions that have been called to get to that line, which will be your call stack. So, if you’re trying to diagnose <code>this</code> binding, use the developer tools to get the call-stack, then find the second item from the top, and that will show you the real call-site.</p>
<p><strong>注意:</strong> 你可以在你的脑海里通过按照顺序查看方法调用调用链来呈现一个调用堆栈，就像我们在代码片段中做的注释一样。但是这个是需要细心的而且易于出错。看调用堆栈的另外一个方式是使用你浏览器的调试工具。大多数现代桌面浏览器都有内置的开发者工具包含一个JS调试器。在上面的代码片段中，你可以在工具中在<code>foo()</code>方法的第一行设置一个断点，或者简单的在第一行插入一个<code>debugger;</code>表达式。当你运行到这一页，调试器会在这个位置暂停，然后将会展示一个在那一行已经被调用的方法列表，这就是你的调用堆栈。所以，如果你试图判断<code>this</code>绑定，使用开发者工具获得调用堆栈，然后从最上面找到第二项，他将会向你展示真正的调用位置。</p>
<h2 id="Nothing-But-Rules"><a href="#Nothing-But-Rules" class="headerlink" title="Nothing But Rules"></a>Nothing But Rules</h2><h2 id="只有规则"><a href="#只有规则" class="headerlink" title="只有规则"></a>只有规则</h2><p>We turn our attention now to <em>how</em> the call-site determines where <code>this</code> will point during the execution of a function.</p>
<p>现在将我们的注意力转到调用位置是<em>如何</em>确定<code>this</code>在一个执行的方法中会指向什么的。</p>
<p>You must inspect the call-site and determine which of 4 rules applies. We will first explain each of these 4 rules independently, and then we will illustrate their order of precedence, if multiple rules <em>could</em> apply to the call-site.</p>
<p>你必须检查调用位置然后决定应用4个规则中的哪一个。首先我们将会各自解释4个规则中每一个，然后我们将会举例说明如果多个规则可以应用于一个调用位置他们的优先顺序。</p>
<h3 id="Default-Binding"><a href="#Default-Binding" class="headerlink" title="Default Binding"></a>Default Binding</h3><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>The first rule we will examine comes from the most common case of function calls: standalone function invocation. Think of <em>this</em> <code>this</code> rule as the default catch-all rule when none of the other rules apply.</p>
<p>我们将要探索的第一个规则是从最常见的方法调用情况中来的:独立方法调用。把这个<code>this</code>规则当做是当没有其他规则应用时的默认规则它是捕获全部的。</p>
<p>Consider this code:</p>
<p>考虑这个代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>The first thing to note, if you were not already aware, is that variables declared in the global scope, as <code>var a = 2</code> is, are synonymous with global-object properties of the same name. They’re not copies of each other, they <em>are</em> each other. Think of it as two sides of the same coin.</p>
<p>如果你还没有意识到,需要注意的第一件事，<code>var a = 2</code>中变量被声明在全局作用域中，他们是全局对象相同名字的属性的同义词。他们不是相互拷贝的，他们就是对方。想象一下一个硬币的两面。</p>
<p>Secondly, we see that when <code>foo()</code> is called, <code>this.a</code> resolves to our global variable <code>a</code>. Why? Because in this case, the <em>default binding</em> for <code>this</code> applies to the function call, and so points <code>this</code> at the global object.</p>
<p>其次，我们看到当<code>foo()</code>被调用，<code>this.a</code>指向的是我们的全局变量<code>a</code>(resolves:to reach a decision by means of a formal vote:根据投票来达成一个决定)。为什么？因为在这个例子中，在这个方法调用中<code>this</code>绑定规则应用了<em>默认绑定</em>，所以<code>this</code>指向了全局作用域。</p>
<p>How do we know that the <em>default binding</em> rule applies here? We examine the call-site to see how <code>foo()</code> is called. In our snippet, <code>foo()</code> is called with a plain, un-decorated function reference. None of the other rules we will demonstrate will apply here, so the <em>default binding</em> applies instead.</p>
<p>我们怎么知道<em>默认绑定</em>规则在这里应用了?我们探究一下调用位置来看<code>foo()</code>是如何被调用的。在我们的代码片段中，<code>foo()</code>是一个平淡无奇的调用，未经装饰的方法引用。没有任何其他我们将展示的规则会在这里应用，所以<em>默认绑定</em>在这里被应用了。</p>
<p>If <code>strict mode</code> is in effect, the global object is not eligible for the <em>default binding</em>, so the <code>this</code> is instead set to <code>undefined</code>.</p>
<p>如果受了<code>strict mode</code>(严格模式)的影响，全局对象作为 <em>default binding</em> 将被认为不合法，所以<code>this</code>会被设置为<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// TypeError: `this` is `undefined`</span></span><br></pre></td></tr></table></figure>
<p>A subtle but important detail is: even though the overall <code>this</code> binding rules are entirely based on the call-site, the global object is <strong>only</strong> eligible for the <em>default binding</em> if the <strong>contents</strong> of <code>foo()</code> are <strong>not</strong> running in <code>strict mode</code>; the <code>strict mode</code> state of the call-site of <code>foo()</code> is irrelevant.</p>
<p>一个微妙但是重要的细节是:即使所有的<code>this</code>绑定规则都是完全基于调用位置的，如果<code>foo()</code>的<strong>内容不是</strong>运行在<code>strict mode</code>(严格模式)下那么全局对象是<strong>唯一</strong>合法的<em>默认绑定</em>；<code>foo()</code>的调用位置和<code>strict mode</code>(严格模式)的状态不相关。(即不受影响)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line"></span><br><span class="line">	foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Intentionally mixing <code>strict mode</code> and non-<code>strict mode</code> together in your own code is generally frowned upon. Your entire program should probably either be <strong>Strict</strong> or <strong>non-Strict</strong>. However, sometimes you include a third-party library that has different <strong>Strict</strong>‘ness than your own code, so care must be taken over these subtle compatibility details.</p>
<p><strong>注意:</strong> 有意的将<code>strict mode</code>和非<code>strict mode</code>在你的代码中混合在一起使用通常是不被推荐的。你的整个程序需要最好只使用<strong>严格模式</strong>或者<strong>非严格模式</strong>其中之一。然而，有时候你会在你的代码中使用和你<strong>严格模式</strong>不一样的第三方库，所以必须小心处理这些微妙的兼容细节。</p>
<h3 id="Implicit-Binding"><a href="#Implicit-Binding" class="headerlink" title="Implicit Binding"></a>Implicit Binding</h3><h3 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h3><p>Another rule to consider is: does the call-site have a context object, also referred to as an owning or containing object, though <em>these</em> alternate terms could be slightly misleading.</p>
<p>另外一个需要考虑的规则是:调用位置是否有一个上下文对象，也成为拥有或者容器对象，尽管<em>这些</em>交替出现的术语可能会有些误导。</p>
<p>Consider:</p>
<p>考虑一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Firstly, notice the manner in which <code>foo()</code> is declared and then later added as a reference property onto <code>obj</code>. Regardless of whether <code>foo()</code> is initially declared <em>on</em> <code>obj</code>, or is added as a reference later (as this snippet shows), in neither case is the <strong>function</strong> really “owned” or “contained” by the <code>obj</code> object.</p>
<p>首先，注意到<code>foo()</code>声明的行为然后接下里作为一个引用属性被附加到<code>obj</code>上。不管<code>foo()</code>是初始化声明在<code>obj</code>上,或者作为一个引用加到上面(就像这段代码一样),这两种情况都是<strong>方法</strong>真正的被<code>obj</code>对象”拥有”或者”包含”。</p>
<p>However, the call-site <em>uses</em> the <code>obj</code> context to <strong>reference</strong> the function, so you <em>could</em> say that the <code>obj</code> object “owns” or “contains” the <strong>function reference</strong> at the time the function is called.</p>
<p>然而，调用位置<em>使用</em><code>obj</code>上下文来<strong>引用</strong>方法，所以你<em>可以</em>说<code>obj</code>对象在方法调用的时候”拥有”或者”包含”<strong>方法引用</strong>。</p>
<p>Whatever you choose to call this pattern, at the point that <code>foo()</code> is called, it’s preceded by an object reference to <code>obj</code>. When there is a context object for a function reference, the <em>implicit binding</em> rule says that it’s <em>that</em> object which should be used for the function call’s <code>this</code> binding.</p>
<p>不论你选择如何称呼这种模式，<code>foo()</code>的被调用是通过一个<code>obj</code>对象引用作为引导的。当一个方法引用使用一个上下文对象时，<em>隐晦绑定</em> 规定规定<em>那个</em>对象需要被用作为方法执行的<code>this</code>绑定值。</p>
<p>Because <code>obj</code> is the <code>this</code> for the <code>foo()</code> call, <code>this.a</code> is synonymous with <code>obj.a</code>.</p>
<p>因为<code>obj</code>是 <code>foo()</code>调用的<code>this</code>，所以<code>this.a</code>是<code>obj.a</code>的同义词。</p>
<p>Only the top/last level of an object property reference chain matters to the call-site. For instance:</p>
<p>调用位置只跟对象属性引用链的最高级/最后级相关。举例来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	a: <span class="number">42</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h4 id="Implicitly-Lost"><a href="#Implicitly-Lost" class="headerlink" title="Implicitly Lost"></a>Implicitly Lost</h4><h4 id="隐晦丢失"><a href="#隐晦丢失" class="headerlink" title="隐晦丢失"></a>隐晦丢失</h4><p>One of the most common frustrations that <code>this</code> binding creates is when an <em>implicitly bound</em> function loses that binding, which usually means it falls back to the <em>default binding</em>, of either the global object or <code>undefined</code>, depending on <code>strict mode</code>.</p>
<p><code>this</code>绑定的创建最常见的挫败是当一个<em>隐晦绑定</em>方法丢失了那个绑定，这通常意味着他退回到<em>默认绑定</em>，<code>this</code>会是全局对象或者<code>undefined</code>二者之一，取决于是否<code>strict mode</code>(严格模式)。</p>
<p>Consider:</p>
<p>考虑一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// function reference/alias!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` also property on global object</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<p>Even though <code>bar</code> appears to be a reference to <code>obj.foo</code>, in fact, it’s really just another reference to <code>foo</code> itself. Moreover, the call-site is what matters, and the call-site is <code>bar()</code>, which is a plain, un-decorated call and thus the <em>default binding</em> applies.</p>
<p>尽管<code>bar</code>似乎是一个指向<code>obj.foo</code>的引用，事实上，他只是<code>foo</code>本身的另外一个引用。此外，调用位置和什么相关，调用位置是<code>bar()</code>，他是一个平淡无奇的调用，未经装饰的调用因此<em>默认绑定</em>应用了。</p>
<p>The more subtle, more common, and more unexpected way this occurs is when we consider passing a callback function:</p>
<p>更微妙，更常见，更意料之外的这种情况的发生是当我们考虑传递一个回调方法时:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// `fn` is just another reference to `foo`</span></span><br><span class="line"></span><br><span class="line">	fn(); <span class="comment">// &lt;-- call-site!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` also property on global object</span></span><br><span class="line"></span><br><span class="line">doFoo( obj.foo ); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<p>Parameter passing is just an implicit assignment, and since we’re passing a function, it’s an implicit reference assignment, so the end result is the same as the previous snippet.</p>
<p>参数传递仅仅是一个隐晦的赋值，一旦我们传递一个方法，这就是一个隐晦的引用赋值，所以最后的结果跟前面的那段代码一样。</p>
<p>What if the function you’re passing your callback to is not your own, but built-in to the language? No difference, same outcome.</p>
<p>那如果将你的方法传入到一个语言内置的方法中而不是你自己的方法来作为回调会发生什么?没什么不一样，一样的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` also property on global object</span></span><br><span class="line"></span><br><span class="line">setTimeout( obj.foo, <span class="number">100</span> ); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<p>Think about this crude theoretical pseudo-implementation of <code>setTimeout()</code> provided as a built-in from the JavaScript environment:</p>
<p>把这个粗略的理论上假装可执行的<code>setTimeout()</code>当做是JavaScript环境提供的内置方法一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// wait (somehow) for `delay` milliseconds</span></span><br><span class="line">	fn(); <span class="comment">// &lt;-- call-site!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s quite common that our function callbacks <em>lose</em> their <code>this</code> binding, as we’ve just seen. But another way that <code>this</code> can surprise us is when the function we’ve passed our callback to intentionally changes the <code>this</code> for the call. Event handlers in popular JavaScript libraries are quite fond of forcing your callback to have a <code>this</code> which points to, for instance, the DOM element that triggered the event. While that may sometimes be useful, other times it can be downright infuriating. Unfortunately, these tools rarely let you choose.</p>
<p>就像我们看到的那样，我们的回调方法<em>丢失</em>他们的<code>this</code>绑定是非常常见的。<code>this</code>让我们吃惊的另外一种方式是当我们传入的回调方法有意的为这次调用改变了<code>this</code>。在流行的JavaScript库中事件处理非常乐于强行将你的回调方法<code>this</code>改变，举个例子，被触发事件的DOM节点。虽然有时候可能有用，其他时候会让人勃然大怒。不幸的是，这些工具很少会让你选择。</p>
<p>Either way the <code>this</code> is changed unexpectedly, you are not really in control of how your callback function reference will be executed, so you have no way (yet) of controlling the call-site to give your intended binding. We’ll see shortly a way of “fixing” that problem by <em>fixing</em> the <code>this</code>.</p>
<p>不管哪一种<code>this</code>出乎意料的改变方式，你不能真正的控制你的回调方法引用会如何被执行，所以你没有办法(至少现在还没有)控制调用位置来给你进行有目的的绑定。我们将马上会看到一种方式通过<em>固定</em><code>this</code>来”修复”这个问题.</p>
<h3 id="Explicit-Binding"><a href="#Explicit-Binding" class="headerlink" title="Explicit Binding"></a>Explicit Binding</h3><h3 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h3><p>With <em>implicit binding</em> as we just saw, we had to mutate the object in question to include a reference on itself to the function, and use this property function reference to indirectly (implicitly) bind <code>this</code> to the object.</p>
<p>就像我们刚看到的<em>隐晦绑定</em>，我们需要转变一个对象在他本身包干一个方法的引用，然后使用这个方法属性间接的(隐晦的)绑定<code>this</code>为这个对象。</p>
<p>But, what if you want to force a function call to use a particular object for the <code>this</code> binding, without putting a property function reference on the object?</p>
<p>但是,如果你想强迫一个方法调用使用一个特定的对象作为<code>this</code>绑定如何在不用将一个属性方法引用放在对象上的方法达到目的？</p>
<p>“All” functions in the language have some utilities available to them (via their <code>[[Prototype]]</code> – more on that later) which can be useful for this task. Specifically, functions have <code>call(..)</code> and <code>apply(..)</code> methods. Technically, JavaScript host environments sometimes provide functions which are special enough (a kind way of putting it!) that they do not have such functionality. But those are few. The vast majority of functions provided, and certainly all functions you will create, do have access to <code>call(..)</code> and <code>apply(..)</code>.</p>
<p>在语言中”所有”方法都有一些工具(经由他们的<code>[[Prototype]]</code> – 更多的后面讲)可用于这个任务。明确的说,函数有<code>call(..)</code> 和 <code>apply(..)</code>方法。技术上来说，JavaScript环境有时候会提供足够特别方法(一种放上去方法)来实现他们没有的功能。但是这很少见。大多数方法被提供，事实上所有你将会创建的方法，他们都可以读取<code>call(..)</code> 和 <code>apply(..)</code>方法。</p>
<p>How do these utilities work? They both take, as their first parameter, an object to use for the <code>this</code>, and then invoke the function with that <code>this</code> specified. Since you are directly stating what you want the <code>this</code> to be, we call it <em>explicit binding</em>.</p>
<p>这些工具是如何工作的？他们都将第一个参数,一个对象来使用作为<code>this</code>，然后执行方法使用这个执行的<code>this</code>。一旦你直接指定你希望哪个作为<code>this</code>，我们叫做<em>明确绑定</em>。</p>
<p>Consider:</p>
<p>考虑一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Invoking <code>foo</code> with <em>explicit binding</em> by <code>foo.call(..)</code> allows us to force its <code>this</code> to be <code>obj</code>.</p>
<p>通过<code>foo.call(..)</code>执行<code>foo</code>使用<em>明确绑定</em> 允许我们强行的<code>this</code>指向<code>obj</code>。</p>
<p>If you pass a simple primitive value (of type <code>string</code>, <code>boolean</code>, or <code>number</code>) as the <code>this</code> binding, the primitive value is wrapped in its object-form (<code>new String(..)</code>, <code>new Boolean(..)</code>, or <code>new Number(..)</code>, respectively). This is often referred to as “boxing”.</p>
<p>如果你传入一个简单的原始值(<code>string</code>, <code>boolean</code>, 或者 <code>number</code>类型)作为<code>this</code>绑定，这个原始值会被他的对象包裹(各自,<code>new String(..)</code>, <code>new Boolean(..)</code>, 或者 <code>new Number(..)</code>)。这通常被叫做”装箱(boxing)”。</p>
<p><strong>Note:</strong> With respect to <code>this</code> binding, <code>call(..)</code> and <code>apply(..)</code> are identical. They <em>do</em> behave differently with their additional parameters, but that’s not something we care about presently.</p>
<p><strong>注意:</strong> 就<code>this</code>绑定而言，<code>call(..)</code> 和 <code>apply(..)</code> 是相同的。但是他们对于他们附加的参数会有不同的行为，这个不是我们现在所要关心的。</p>
<p>Unfortunately, <em>explicit binding</em> alone still doesn’t offer any solution to the issue mentioned previously, of a function “losing” its intended <code>this</code> binding, or just having it paved over by a framework, etc.</p>
<p>不幸的是，<em>明确绑定</em> 自己仍然没有提供任何解决方案用来解决我们之前提到过的问题，一个方法”丢失”他自己原本打算的<code>this</code>绑定，或者被一个框架覆盖,等等。</p>
<h4 id="Hard-Binding"><a href="#Hard-Binding" class="headerlink" title="Hard Binding"></a>Hard Binding</h4><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>But a variation pattern around <em>explicit binding</em> actually does the trick. Consider:</p>
<p>但是<em>明确绑定</em>的一种变化形式的确可以完成这个戏法。考虑一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `bar` hard binds `foo`'s `this` to `obj`</span></span><br><span class="line"><span class="comment">// so that it cannot be overriden</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Let’s examine how this variation works. We create a function <code>bar()</code> which, internally, manually calls <code>foo.call(obj)</code>, thereby forcibly invoking <code>foo</code> with <code>obj</code> binding for <code>this</code>. No matter how you later invoke the function <code>bar</code>, it will always manually invoke <code>foo</code> with <code>obj</code>. This binding is both explicit and strong, so we call it <em>hard binding</em>.</p>
<p>让我们来探究下这个变化是如何工作的。我们创建一个方法<code>bar()</code>内部手动调用<code>foo.call(obj)</code>，此外执行<code>foo</code>强行将<code>this</code>绑定指向<code>obj</code>。不管你多晚执行方法<code>bar</code>，他都将会手动执行<code>foo</code>使用<code>obj</code>。这个绑定明确而且强壮，所以我们叫做 <em>硬绑定</em>.</p>
<p>The most typical way to wrap a function with a <em>hard binding</em> creates a pass-thru of any arguments passed and any return value received:</p>
<p>最典型的包裹一个方法使用<em>硬绑定</em>的方式是创建可以传入任何参数和接受任何返回值的通道。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> foo.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>Another way to express this pattern is to create a re-usable helper:</p>
<p>另外一种这个模式的表现是创建一个可重复使用的helper：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple `bind` helper</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = bind( foo, obj );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>Since <em>hard binding</em> is such a common pattern, it’s provided with a built-in utility as of ES5: <code>Function.prototype.bind</code>, and it’s used like this:</p>
<p>因为<em>硬绑定</em>是一种很常用的模式，ES5提供了内置的工具:<code>Function.prototype.bind</code>，它使用起来就像这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><code>bind(..)</code> returns a new function that is hard-coded to call the original function with the <code>this</code> context set as you specified.</p>
<p><code>bind(..)</code> 返回一个根据原始方法按照你执行的<code>this</code>上下文的硬编码的新方法。</p>
<p><strong>Note:</strong> As of ES6, the hard-bound function produced by <code>bind(..)</code> has a <code>.name</code> property that derives from the original <em>target function</em>. For example: <code>bar = foo.bind(..)</code> should have a <code>bar.name</code> value of <code>&quot;bound foo&quot;</code>, which is the function call name that should show up in a stack trace.</p>
<p><strong>注意:</strong> 在ES6中，<code>bind(..)</code>生产的硬绑定方法有一个<code>.name</code>属性源于原始的<em>目标方法</em>。举个例子:<code>bar = foo.bind(..)</code>会有一个<code>bar.name</code>值是<code>&quot;bound foo&quot;</code>，他是应该在调用跟踪里显示的方法调用名称。</p>
<h4 id="API-Call-“Contexts”"><a href="#API-Call-“Contexts”" class="headerlink" title="API Call “Contexts”"></a>API Call “Contexts”</h4><h4 id="API调用”上下文”"><a href="#API调用”上下文”" class="headerlink" title="API调用”上下文”"></a>API调用”上下文”</h4><p>Many libraries’ functions, and indeed many new built-in functions in the JavaScript language and host environment, provide an optional parameter, usually called “context”, which is designed as a work-around for you not having to use <code>bind(..)</code> to ensure your callback function uses a particular <code>this</code>.</p>
<p>许多库的方法，许多新的JavaScript语言和宿主环境的内置方法，提供一个可选的参数，通常叫做”上下文”，设计用来在不需要使用<code>bind(..)</code>情况下确保你的回调用法使用一个指定的<code>this</code>。</p>
<p>For instance:</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	id: <span class="string">"awesome"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use `obj` as `this` for `foo(..)` calls</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj ); <span class="comment">// 1 awesome  2 awesome  3 awesome</span></span><br></pre></td></tr></table></figure>
<p>Internally, these various functions almost certainly use <em>explicit binding</em> via <code>call(..)</code> or <code>apply(..)</code>, saving you the trouble.</p>
<p>本质上，这些变化方法几乎可以确定经由<code>call(..)</code> 或者 <code>apply(..)</code>方法使用了<em>明确绑定</em>，拯救了你的麻烦。</p>
<h3 id="new-Binding"><a href="#new-Binding" class="headerlink" title="new Binding"></a><code>new</code> Binding</h3><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a><code>new</code>绑定</h3><p>The fourth and final rule for <code>this</code> binding requires us to re-think a very common misconception about functions and objects in JavaScript.</p>
<p>第四个也是最后一个<code>this</code>绑定规则需要我们重新回想一个关于在JavaScript中方法和对象非常常见的错误观念。</p>
<p>In traditional class-oriented languages, “constructors” are special methods attached to classes, that when the class is instantiated with a <code>new</code> operator, the constructor of that class is called. This usually looks something like:</p>
<p>在传统的的面向类的语言中，”构造器”是类的一个特殊方法，当类通过一个<code>new</code>得到实例化，类的构造方法会被调用。通常看起来是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = <span class="keyword">new</span> MyClass(..);</span><br></pre></td></tr></table></figure>
<p>JavaScript has a <code>new</code> operator, and the code pattern to use it looks basically identical to what we see in those class-oriented languages; most developers assume that JavaScript’s mechanism is doing something similar. However, there really is <em>no connection</em> to class-oriented functionality implied by <code>new</code> usage in JS.</p>
<p>JavaScript也有一个<code>new</code>操作符，代码模式基本上看起来和那些面向类的语言差不多；许多开发者会假设JavaScript的机制会做相似的操作。然而，在JS中使用<code>new</code>关键字看起来暗示和面向类的功能方法但是和面向类的功能方法是真的”没有联系”。</p>
<p>First, let’s re-define what a “constructor” in JavaScript is. In JS, constructors are <strong>just functions</strong> that happen to be called with the <code>new</code> operator in front of them. They are not attached to classes, nor are they instantiating a class. They are not even special types of functions. They’re just regular functions that are, in essence, hijacked by the use of <code>new</code> in their invocation.</p>
<p>首先，来重新定义一下在JavaScript中什么是”构造器”。在JS中，构造器<strong>仅仅是方法</strong>调用发生在在他们前面使用<code>new</code>操作调用时，他们不依附于类，也不会实例化一个类。他们甚至不是一个特殊类型的方法。他们只是平常的方法，本质上，是通过在他们执行时使用<code>new</code>来进行操作。</p>
<p>For example, the <code>Number(..)</code> function acting as a constructor, quoting from the ES5.1 spec:</p>
<p>举个例子，<code>Number(..)</code>方法表现起来就像一个构造器，引用ES5.1的描述:</p>
<blockquote>
<p>15.7.2 The Number Constructor</p>
</blockquote>
<blockquote>
<p>15.7.2 数字构造器</p>
<p>When Number is called as part of a new expression it is a constructor: it initialises the newly created object.</p>
</blockquote>
<blockquote>
<p>当数字被作为一个new表达式的一部分被调用时这就是一个构造器:初始化创造一个新的对象。</p>
</blockquote>
<p>So, pretty much any ol’ function, including the built-in object functions like <code>Number(..)</code> (see Chapter 3) can be called with <code>new</code> in front of it, and that makes that function call a <em>constructor call</em>. This is an important but subtle distinction: there’s really no such thing as “constructor functions”, but rather construction calls <em>of</em> functions.</p>
<p>所以，许多方法,包括内置的对象方法像<code>Number(..)</code>(见第三章)可以在前面使用<code>new</code>调用，这样使方法变成一个<em>构造器调用</em>。这里有一个重要但是微妙的细节:他们实际上没有类似像”构造方法”，但是有函数的构造调用。</p>
<p>When a function is invoked with <code>new</code> in front of it, otherwise known as a constructor call, the following things are done automatically:</p>
<p>当一个方法在前面加上<code>new</code>被调用，被称作一个构造器调用，下面的事情将会自动执行：</p>
<ol>
<li>a brand new object is created (aka, constructed) out of thin air</li>
<li>一个崭新的对象会凭空被创建(又称作被构造)</li>
<li><em>the newly constructed object is <code>[[Prototype]]</code>-linked</em></li>
<li><em>新的被构造的对象会被连接上<code>[[Prototype]]</code></em></li>
<li>the newly constructed object is set as the <code>this</code> binding for that function call</li>
<li>新的被构造的对象会作为方法调用的<code>this</code>绑定</li>
<li>unless the function returns its own alternate <strong>object</strong>, the <code>new</code>-invoked function call will <em>automatically</em> return the newly constructed object.</li>
<li>除非方法返回它自己的<strong>对象</strong>，否则<code>new</code>新的被执行的方法调用会<em>自动</em>返回新的被构造完的对象。</li>
</ol>
<p>Steps 1, 3, and 4 apply to our current discussion. We’ll skip over step 2 for now and come back to it in Chapter 5.</p>
<p>第1,3和4步适用于我们现在的讨论，我们现在将会跳过第二步在第五章在回来讨论他。</p>
<p>Consider this code:</p>
<p>考虑一下这个代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>By calling <code>foo(..)</code> with <code>new</code> in front of it, we’ve constructed a new object and set that new object as the <code>this</code> for the call of <code>foo(..)</code>. <strong>So <code>new</code> is the final way that a function call’s <code>this</code> can be bound.</strong> We’ll call this <em>new binding</em>.</p>
<p>通过把<code>new</code>放在<code>foo(..)</code>之前调用方法，我们构造得到一个新的对象然后设置这个新的对象作为<code>foo(..)</code>调用的<code>this</code>绑定。<strong>所以<code>new</code>是最后一种将一个方法的<code>this</code>绑定的方式</strong> 我们称之为<em>new绑定</em>。</p>
<h2 id="Everything-In-Order"><a href="#Everything-In-Order" class="headerlink" title="Everything In Order"></a>Everything In Order</h2><h2 id="所有的排序"><a href="#所有的排序" class="headerlink" title="所有的排序"></a>所有的排序</h2><p>So, now we’ve uncovered the 4 rules for binding <code>this</code> in function calls. <em>All</em> you need to do is find the call-site and inspect it to see which rule applies. But, what if the call-site has multiple eligible rules? There must be an order of precedence to these rules, and so we will next demonstrate what order to apply the rules.</p>
<p>所以，现在我们揭开了<code>this</code>绑定在方法调用中的4种规则。你需要做的仅仅是找到调用位置然后检查哪种规则被应用。但是，如果调用位置有第一个适用规则怎么办？我们必须给这些规则按优先级排一下序，所以我们将接下来说明这些规则应用的顺序。</p>
<p>It should be clear that the <em>default binding</em> is the lowest priority rule of the 4. So we’ll just set that one aside.</p>
<p>应该要清楚<em>默认绑定</em>是4种规则中优先级最低的。说我们会先将他放在一边。</p>
<p>Which is more precedent, <em>implicit binding</em> or <em>explicit binding</em>? Let’s test it:</p>
<p>哪个在更前面，<em>隐晦绑定</em> 或是 <em>明确绑定</em> ?让我们测试以下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	a: <span class="number">3</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(); <span class="comment">// 2</span></span><br><span class="line">obj2.foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.foo.call( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>So, <em>explicit binding</em> takes precedence over <em>implicit binding</em>, which means you should ask <strong>first</strong> if <em>explicit binding</em> applies before checking for <em>implicit binding</em>.</p>
<p>所以，<em>明确绑定</em> 比 <em>隐晦绑定</em> 有更高的优先权，这意味着你应该检查<em>隐晦绑定</em>之前<strong>先</strong>检查<em>明确绑定</em>是否被适用。</p>
<p>Now, we just need to figure out where <em>new binding</em> fits in the precedence.</p>
<p>现在，我们只需要搞清楚<em>new绑定</em>在优先顺序中的合适位置就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2, <span class="number">3</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj2.a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo( <span class="number">4</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>OK, <em>new binding</em> is more precedent than <em>implicit binding</em>. But do you think <em>new binding</em> is more or less precedent than <em>explicit binding</em>?</p>
<p>OK,<em>new绑定</em> 比 <em>隐晦绑定</em> 有更高的优先权。但是你觉得<em>new绑定</em>比<em>明确绑定</em>的优先权是高还是低呢?</p>
<p><strong>Note:</strong> <code>new</code> and <code>call</code>/<code>apply</code> cannot be used together, so <code>new foo.call(obj1)</code> is not allowed, to test <em>new binding</em> directly against <em>explicit binding</em>. But we can still use a <em>hard binding</em> to test the precedence of the two rules.</p>
<p><strong>注意:</strong><code>new</code>和<code>call</code>/<code>apply</code>不可以在一起使用,所以<code>new foo.call(obj1)</code>是不被允许的，所以无法直接测试<em>new绑定</em>和<em>明确绑定</em>。但是我们仍然可以使用一个<em>硬绑定</em>来测试这两种规则的优先权。</p>
<p>Before we explore that in a code listing, think back to how <em>hard binding</em> physically works, which is that <code>Function.prototype.bind(..)</code> creates a new wrapper function that is hard-coded to ignore its own <code>this</code> binding (whatever it may be), and use a manual one we provide.</p>
<p>在我们在代码中探索之前，回想一下<em>硬绑定</em>是如何工作的，<code>Function.prototype.bind(..)</code>创建一个新的包围方法强行的忽略本身的<code>this</code>绑定(不论是否存在)，然后使用一个我们手工提供的一个。</p>
<p>By that reasoning, it would seem obvious to assume that <em>hard binding</em> (which is a form of <em>explicit binding</em>) is more precedent than <em>new binding</em>, and thus cannot be overridden with <code>new</code>.</p>
<p>因为这个原因，显然可以假设<em>硬绑定</em> (<em>明确绑定</em> 的一种类型)比<em>new绑定</em>的优先级更高，因此不能被new覆盖。</p>
<p>Let’s check:</p>
<p>让我们检查一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj1 );</span><br><span class="line">bar( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar( <span class="number">3</span> );</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a ); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log( baz.a ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>Whoa! <code>bar</code> is hard-bound against <code>obj1</code>, but <code>new bar(3)</code> did <strong>not</strong> change <code>obj1.a</code> to be <code>3</code> as we would have expected. Instead, the <em>hard bound</em> (to <code>obj1</code>) call to <code>bar(..)</code> <strong><em>is</em></strong> able to be overridden with <code>new</code>. Since <code>new</code> was applied, we got the newly created object back, which we named <code>baz</code>, and we see in fact that  <code>baz.a</code> has the value <code>3</code>.</p>
<p>哇哦！<code>bar</code>紧紧的强行绑定住<code>obj1</code>，但是<code>new bar(3)</code>事实上<strong>没有</strong>像我们期望的那样将<code>obj1.a</code>修改为<code>3</code>。相反的，<code>bar(..)</code>调用的<em>硬绑定</em>(对<code>obj1</code>的)<strong><em>是</em></strong> 可以通过<code>new</code>覆盖的。一旦<code>new</code>被应用，我们获得了一个新创建的对象，我们取名叫<code>baz</code>，然后我们看到事实上<code>baz.a</code>的值是<code>3</code>。</p>
<p>This should be surprising if you go back to our “fake” bind helper:</p>
<p>如果你回过头来看我们之前”假的”绑定helper你应该会吃惊：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		fn.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you reason about how the helper’s code works, it does not have a way for a <code>new</code> operator call to override the hard-binding to <code>obj</code> as we just observed.</p>
<p>如果你想知道helper的代码是如何工作的原因，这不会有像我们观察到的的一样的方式用一个<code>new</code>调用来覆盖硬绑定的<code>obj</code>。</p>
<p>But the built-in <code>Function.prototype.bind(..)</code> as of ES5 is more sophisticated, quite a bit so in fact. Here is the (slightly reformatted) polyfill provided by the MDN page for <code>bind(..)</code>:</p>
<p>但是ES5内置的<code>Function.prototype.bind(..)</code>更复杂，事实上复杂的多。这里是(稍微重新格式化了一下)MDN提供的<code>bind(..)</code>的polyfill：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">	<span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">			<span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">			<span class="comment">// internal IsCallable function</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>( <span class="string">"Function.prototype.bind - what "</span> +</span><br><span class="line">				<span class="string">"is trying to be bound is not callable"</span></span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> ),</span><br><span class="line">			fToBind = <span class="keyword">this</span>,</span><br><span class="line">			fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">			fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> fToBind.apply(</span><br><span class="line">					(</span><br><span class="line">						<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp;</span><br><span class="line">						oThis ? <span class="keyword">this</span> : oThis</span><br><span class="line">					),</span><br><span class="line">					aArgs.concat( <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span> ) )</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">		fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">		fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> fBound;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The <code>bind(..)</code> polyfill shown above differs from the built-in <code>bind(..)</code> in ES5 with respect to hard-bound functions that will be used with <code>new</code> (see below for why that’s useful). Because the polyfill cannot create a function without a <code>.prototype</code> as the built-in utility does, there’s some nuanced indirection to approximate the same behavior. Tread carefully if you plan to use <code>new</code> with a hard-bound function and you rely on this polyfill.</p>
<p><strong>注意:</strong> <code>bind(..)</code>polyfill和ES5内置的<code>bind(..)</code>在方法硬绑定上使用了不一样的方式,这个polyfill使用了<code>new</code>(为什么这么用见下面)。因为polyfill不能像内置方法一样在不使用一个<code>.prototype</code>的情况下创建一个方法，使用一些微妙间接的方式来达到相似的行为。如果你计划使用<code>new</code>来做方法硬绑定而且依赖这个polyfill那你就需要小心对待了。</p>
<p>The part that’s allowing <code>new</code> overriding is:</p>
<p>这个部分允许<code>new</code>覆盖是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp;</span><br><span class="line">oThis ? <span class="keyword">this</span> : oThis</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and:</span></span><br><span class="line"></span><br><span class="line">fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">fBound.prototype = <span class="keyword">new</span> fNOP();</span><br></pre></td></tr></table></figure>
<p>We won’t actually dive into explaining how this trickery works (it’s complicated and beyond our scope here), but essentially the utility determines whether or not the hard-bound function has been called with <code>new</code> (resulting in a newly constructed object being its <code>this</code>), and if so, it uses <em>that</em> newly created <code>this</code> rather than the previously specified <em>hard binding</em> for <code>this</code>.</p>
<p>我们事实上不是深究去解释这个把戏是如何工作的(这个跟作用域有关并且比我们这里讨论的复杂),但是事实上这个工具判断硬绑定是否通过<code>new</code>(导致一个新的被初始化的对象变成了<code>this</code>)来调用，如果是的话，他会使用那个新创建的 <code>this</code> 而不是之前<em>硬绑定</em>指定的<code>this</code>。</p>
<p>Why is <code>new</code> being able to override <em>hard binding</em> useful?</p>
<p>为什么<code>new</code>可以覆盖<em>硬绑定</em>那么有用?</p>
<p>The primary reason for this behavior is to create a function (that can be used with <code>new</code> for constructing objects) that essentially ignores the <code>this</code> <em>hard binding</em> but which presets some or all of the function’s arguments. One of the capabilities of <code>bind(..)</code> is that any arguments passed after the first <code>this</code> binding argument are defaulted as standard arguments to the underlying function (technically called “partial application”, which is a subset of “currying”).</p>
<p>这个行为有用的主要原因是创建一个方法(他可以通过使用<code>new</code>来创建对象)他本质上可以忽略预先设置了一些或者全部方法参数的<em>硬绑定</em>的<code>this</code>.<code>bind(..)</code>的其中一个能力是在第一个<code>this</code>绑定参数的后面的任何一个被传入的参数默认作为后面方法的标准参数(技术上称作”部分应用”，他是一种”currying”).</p>
<p>For example:</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p1,p2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.val = p1 + p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using `null` here because we don't care about</span></span><br><span class="line"><span class="comment">// the `this` hard-binding in this scenario, and</span></span><br><span class="line"><span class="comment">// it will be overridden by the `new` call anyway!</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="string">"p1"</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar( <span class="string">"p2"</span> );</span><br><span class="line"></span><br><span class="line">baz.val; <span class="comment">// p1p2</span></span><br></pre></td></tr></table></figure>
<h3 id="Determining-this"><a href="#Determining-this" class="headerlink" title="Determining this"></a>Determining <code>this</code></h3><h3 id="查明this"><a href="#查明this" class="headerlink" title="查明this"></a>查明<code>this</code></h3><p>Now, we can summarize the rules for determining <code>this</code> from a function call’s call-site, in their order of precedence. Ask these questions in this order, and stop when the first rule applies.</p>
<p>现在，我们可以总结从一个方法的调用位置如何查明他应用了哪个<code>this</code>规则，根据他们的优先顺序。根据他们顺序提出这些问题，第一个应用规则找到时停止。</p>
<ol>
<li><p>Is the function called with <code>new</code> (<strong>new binding</strong>)? If so, <code>this</code> is the newly constructed object.</p>
</li>
<li><p>方法是否通过<code>new</code>调用(<strong>new绑定</strong>)?如果是的话, <code>this</code>是新的构建完的对象。</p>
<p> <code>var bar = new foo()</code></p>
</li>
<li><p>Is the function called with <code>call</code> or <code>apply</code> (<strong>explicit binding</strong>), even hidden inside a <code>bind</code> <em>hard binding</em>? If so, <code>this</code> is the explicitly specified object.</p>
</li>
<li><p>方法是否通过<code>call</code> 或者 <code>apply</code>调用(<strong>明确绑定</strong>),或者是隐藏在<code>bind</code>之中 <em>硬绑定</em>?如果是的话, <code>this</code>是明确指定的对象。</p>
<p> <code>var bar = foo.call( obj2 )</code></p>
</li>
<li><p>Is the function called with a context (<strong>implicit binding</strong>), otherwise known as an owning or containing object? If so, <code>this</code> is <em>that</em> context object.</p>
</li>
<li><p>方法是否通过上下文调用(<strong>隐含绑定</strong>),亦或者是他自己或者包含的对象?如果是的话,<code>this</code>是那个上下文对象.</p>
<p> <code>var bar = obj1.foo()</code></p>
</li>
<li><p>Otherwise, default the <code>this</code> (<strong>default binding</strong>). If in <code>strict mode</code>, pick <code>undefined</code>, otherwise pick the <code>global</code> object.</p>
</li>
<li><p>最后,默认的<code>this</code>(<strong>默认绑定</strong>).如果是在<code>strict mode</code>(严格模式)下,选取<code>undefined</code>值，否则的话会选取<code>global</code>对象。</p>
<p> <code>var bar = foo()</code></p>
</li>
</ol>
<p>That’s it. That’s <em>all it takes</em> to understand the rules of <code>this</code> binding for normal function calls. Well… almost.</p>
<p>这个就是需要了解普通方法调用的 <code>this</code> 绑定规则的全部东西. Well…几乎是。</p>
<h2 id="Binding-Exceptions"><a href="#Binding-Exceptions" class="headerlink" title="Binding Exceptions"></a>Binding Exceptions</h2><h2 id="绑定特例"><a href="#绑定特例" class="headerlink" title="绑定特例"></a>绑定特例</h2><p>As usual, there are some <em>exceptions</em> to the “rules”.</p>
<p>通常情况下,这些”规则”有一些特例.</p>
<p>The <code>this</code>-binding behavior can in some scenarios be surprising, where you intended a different binding but you end up with binding behavior from the <em>default binding</em> rule (see previous).</p>
<p><code>this</code>绑定的举止可以和一些预先设想好的不太一样令人吃惊，你可能获得一个<em>默认绑定</em>规则的绑定行为这个和你原本打算的绑定不太一样(见前面).</p>
<h3 id="Ignored-this"><a href="#Ignored-this" class="headerlink" title="Ignored this"></a>Ignored <code>this</code></h3><h3 id="忽略this"><a href="#忽略this" class="headerlink" title="忽略this"></a>忽略<code>this</code></h3><p>If you pass <code>null</code> or <code>undefined</code> as a <code>this</code> binding parameter to <code>call</code>, <code>apply</code>, or <code>bind</code>, those values are effectively ignored, and instead the <em>default binding</em> rule applies to the invocation.</p>
<p>如果你将<code>null</code> or <code>undefined</code>作为一个<code>this</code>绑定参数传入到 <code>call</code>, <code>apply</code>, 或者 <code>bind</code>中，这些值会被忽略，取而代之的是<em>默认绑定</em>规则被这次执行所应用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo.call( <span class="literal">null</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Why would you intentionally pass something like <code>null</code> for a <code>this</code> binding?</p>
<p>为什么你有意的传入一些类似<code>null</code>的值作为一个<code>this</code>绑定?</p>
<p>It’s quite common to use <code>apply(..)</code> for spreading out arrays of values as parameters to a function call. Similarly, <code>bind(..)</code> can curry parameters (pre-set values), which can be very helpful.</p>
<p>在使用<code>apply(..)</code>时将一个值的平铺数组作为参数传入一个方法调用时很常见的。类似的，<code>bind(..)</code>可以curry参数(预先设置参数)，这可以非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spreading out array as parameters</span></span><br><span class="line">foo.apply( <span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>] ); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// currying with `bind(..)`</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>
<p>Both these utilities require a <code>this</code> binding for the first parameter. If the functions in question don’t care about <code>this</code>, you need a placeholder value, and <code>null</code> might seem like a reasonable choice as shown in this snippet.</p>
<p>这些工具都需要一个<code>this</code>绑定作为第一个参数。如果方法不在乎什么作为<code>this</code>，你需要一个占位值，在这个代码片段中<code>null</code>看起来似乎像一个合理的选择。</p>
<p><strong>Note:</strong> We don’t cover it in this book, but ES6 has the <code>...</code> spread operator which will let you syntactically “spread out” an array as parameters without needing <code>apply(..)</code>, such as <code>foo(...[1,2])</code>, which amounts to <code>foo(1,2)</code> – syntactically avoiding a <code>this</code> binding if it’s unnecessary. Unfortunately, there’s no ES6 syntactic substitute for currying, so the <code>this</code> parameter of the <code>bind(..)</code> call still needs attention.</p>
<p><strong>注意:</strong> ES6中有<code>...</code>的铺开操作他可以让你按照语法的在不需要<code>apply(..)</code>的情况下”展开”一个数组作为参数，就像<code>foo(...[1,2])</code>，他会展开成为<code>foo(1,2)</code> – 语法上在不是必须的情况下避免一个 <code>this</code> 绑定。遗憾的是，ES6语法中没有用于替代克里化的，所以<code>bind(..)</code>调用的 的<code>this</code> 参数仍然需要注意。</p>
<p>However, there’s a slight hidden “danger” in always using <code>null</code> when you don’t care about the <code>this</code> binding. If you ever use that against a function call (for instance, a third-party library function that you don’t control), and that function <em>does</em> make a <code>this</code> reference, the <em>default binding</em> rule means it might inadvertently reference (or worse, mutate!) the <code>global</code> object (<code>window</code> in the browser).</p>
<p>然而,当你不在意<code>this</code>绑定时经常使用<code>null</code>会一个隐藏的小问题。当你在方法中这样使用(举例来说,一个你没办法控制的第三方库的方法)，而且这个方法使用了一个 <code>this</code> 引用，<em>默认绑定</em> 规则会无意(或者更糟糕)的引用<code>global</code>对象(在浏览器中为<code>window</code>)。</p>
<p>Obviously, such a pitfall can lead to a variety of <em>very difficult</em> to diagnose/track-down bugs.</p>
<p>显然，这样陷阱会导致各种各样非常难以诊断/跟踪的bug。</p>
<h4 id="Safer-this"><a href="#Safer-this" class="headerlink" title="Safer this"></a>Safer <code>this</code></h4><h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的<code>this</code></h4><p>Perhaps a somewhat “safer” practice is to pass a specifically set up object for <code>this</code> which is guaranteed not to be an object that can create problematic side effects in your program. Borrowing terminology from networking (and the military), we can create a “DMZ” (de-militarized zone) object – nothing more special than a completely empty, non-delegated (see Chapters 5 and 6) object.</p>
<p>也许某种”更安全”的实践是传一个已经设置好的执行的对象作为<code>this</code>这样可以保证这个对象不会创造问题来影响你的程序。从网络(和军事)上借用一个专用名词,我们可以创建一个”DMZ”(安全区域)对象 – 一个平淡无奇的完全空,没有委托(见第5章和第6章)的对象。</p>
<p>If we always pass a DMZ object for ignored <code>this</code> bindings we don’t think we need to care about, we’re sure any hidden/unexpected usage of <code>this</code> will be restricted to the empty object, which insulates our program’s <code>global</code> object from side-effects.</p>
<p>如果我们认为我们不需要在意一个方法的<code>this</code>绑定时始终传入一个DMZ对象来忽略<code>this</code> bindings，我们可以确定任何隐藏/无意的使用<code>this</code>将会受到空对象的约束，这样可以免除我们程序<code>global</code>对象的影响。</p>
<p>Since this object is totally empty, I personally like to give it the variable name <code>ø</code> (the lowercase mathematical symbol for the empty set). On many keyboards (like US-layout on Mac), this symbol is easily typed with <code>⌥</code>+<code>o</code> (option+<code>o</code>). Some systems also let you set up hotkeys for specific symbols. If you don’t like the <code>ø</code> symbol, or your keyboard doesn’t make that as easy to type, you can of course call it whatever you want.</p>
<p>一旦对象完全为空，我个人喜欢给一个变量名称<code>ø</code>(小写的数学符号代表空集)。在很多键盘上(像MAC上的US-layout),这个符号可以使用<code>⌥</code>+<code>o</code> (option+<code>o</code>)很简单的打出来。一些系统也可以让你为这个特殊符号设置热键。如果你不喜欢<code>ø</code>符号,或者你的键盘不能让很简单的打出来，你当然可以取任何你想要的名字。</p>
<p>Whatever you call it, the easiest way to set it up as <strong>totally empty</strong> is <code>Object.create(null)</code> (see Chapter 5). <code>Object.create(null)</code> is similar to <code>{ }</code>, but without the delegation to <code>Object.prototype</code>, so it’s “more empty” than just <code>{ }</code>.</p>
<p>不论你叫他声明，设置一个<strong>完全为空</strong>最简单的方式是<code>Object.create(null)</code>(见第五章).<code>Object.create(null)</code>和<code>{ }</code>相类似,但是<code>Object.create(null)</code>没有<code>Object.prototype</code>的委托，所以这个比<code>{ }</code>来的更空。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// our DMZ empty object</span></span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create( <span class="literal">null</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// spreading out array as parameters</span></span><br><span class="line">foo.apply( ø, [<span class="number">2</span>, <span class="number">3</span>] ); <span class="comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// currying with `bind(..)`</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( ø, <span class="number">2</span> );</span><br><span class="line">bar( <span class="number">3</span> ); <span class="comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure>
<p>Not only functionally “safer”, there’s a sort of stylistic benefit to <code>ø</code>, in that it semantically conveys “I want the <code>this</code> to be empty” a little more clearly than <code>null</code> might. But again, name your DMZ object whatever you prefer.</p>
<p>不仅仅是方法上的”更安全”，这对代码风格上<code>ø</code>也有益处，这个从语义上传达”我想要<code>this</code>完全为空”这比<code>null</code>看起来更清楚。但是在说一遍，只要你觉得更好随便怎么样给你的DMZ对象取名。</p>
<h3 id="Indirection"><a href="#Indirection" class="headerlink" title="Indirection"></a>Indirection</h3><h3 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h3><p>Another thing to be aware of is you can (intentionally or not!) create “indirect references” to functions, and in those cases,  when that function reference is invoked, the <em>default binding</em> rule also applies.</p>
<p>另外一个需要知道的是你可以(有意或者无意)给方法创建”间接引用”，在这些情况下，当那个方法引用被执行，<em>默认绑定</em> 规则也被引用。</p>
<p>One of the most common ways that <em>indirect references</em> occur is from an assignment:</p>
<p><em>间接引用</em> 发生最常见的的一种方式是一个赋值表达式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>The <em>result value</em> of the assignment expression <code>p.foo = o.foo</code> is a reference to just the underlying function object. As such, the effective call-site is just <code>foo()</code>, not <code>p.foo()</code> or <code>o.foo()</code> as you might expect. Per the rules above, the <em>default binding</em> rule applies.</p>
<p>赋值表达式<code>p.foo = o.foo</code>的结果值是一个隐含的方法对象的引用。因为这样,有效的调用位置是<code>foo()</code>，不是你预期中的 <code>p.foo()</code> 或者 <code>o.foo()</code>。根据上面提到的规则，<em>默认绑定</em> 规则被引用。</p>
<p>Reminder: regardless of how you get to a function invocation using the <em>default binding</em> rule, the <code>strict mode</code> status of the <strong>contents</strong> of the invoked function making the <code>this</code> reference – not the function call-site – determines the <em>default binding</em> value: either the <code>global</code> object if in non-<code>strict mode</code> or <code>undefined</code> if in <code>strict mode</code>.</p>
<p>提醒：不论你怎么得到引用了<em>默认绑定</em> 规则的方法调用，被调用的内容的<code>strict mode</code>(严格模式)状态决定了<code>this</code>引用 – 不是方法调用位置 – 查明<em>默认绑定</em>的值:如果是非<code>strict mode</code>就是<code>global</code> 对象如果是<code>strict mode</code>就是 <code>undefined</code>。</p>
<h3 id="Softening-Binding"><a href="#Softening-Binding" class="headerlink" title="Softening Binding"></a>Softening Binding</h3><h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>We saw earlier that <em>hard binding</em> was one strategy for preventing a function call falling back to the <em>default binding</em> rule inadvertently, by forcing it to be bound to a specific <code>this</code> (unless you use <code>new</code> to override it!). The problem is, <em>hard-binding</em> greatly reduces the flexibility of a function, preventing manual <code>this</code> override with either the <em>implicit binding</em> or even subsequent <em>explicit binding</em> attempts.</p>
<p>我们看见之前的<em>硬绑定</em>是一种防止方法调用在无意的情况下退回到使用<em>默认绑定</em>的策略，强迫他绑定一个指定的 <code>this</code> (至少你使用<code>new</code>去覆盖他)。问题是，<em>硬绑定</em> 大大的约束了方法的灵活性，预防手动的 <code>this</code>覆盖不论是<em>隐晦绑定</em>或者是随后的试图<em>明确绑定</em>。</p>
<p>It would be nice if there was a way to provide a different default for <em>default binding</em> (not <code>global</code> or <code>undefined</code>), while still leaving the function able to be manually <code>this</code> bound via <em>implicit binding</em> or <em>explicit binding</em> techniques.</p>
<p>如果有一种方式提供一种不一样的<em>默认绑定</em>方式(不是<code>global</code> 或者 <code>undefined</code>)这将会很棒，同时也可以让方法经由<em>隐晦绑定</em>或者<em>明确绑定</em>技术手动绑定<code>this</code>。</p>
<p>We can construct a so-called <em>soft binding</em> utility which emulates our desired behavior.</p>
<p>我们可以构建一个称作<em>软绑定</em>的工具来模仿我们想要得到的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">	<span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> fn = <span class="keyword">this</span>,</span><br><span class="line">			curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> ),</span><br><span class="line">			bound = <span class="function"><span class="keyword">function</span> <span class="title">bound</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> fn.apply(</span><br><span class="line">					(!<span class="keyword">this</span> ||</span><br><span class="line">						(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">							<span class="keyword">this</span> === <span class="built_in">window</span>) ||</span><br><span class="line">						(<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">							<span class="keyword">this</span> === global)</span><br><span class="line">					) ? obj : <span class="keyword">this</span>,</span><br><span class="line">					curried.concat.apply( curried, <span class="built_in">arguments</span> )</span><br><span class="line">				);</span><br><span class="line">			&#125;;</span><br><span class="line">		bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</span><br><span class="line">		<span class="keyword">return</span> bound;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>softBind(..)</code> utility provided here works similarly to the built-in ES5 <code>bind(..)</code> utility, except with our <em>soft binding</em> behavior. It wraps the specified function in logic that checks the <code>this</code> at call-time and if it’s <code>global</code> or <code>undefined</code>, uses a pre-specified alternate <em>default</em> (<code>obj</code>). Otherwise the <code>this</code> is left untouched. It also provides optional currying (see the <code>bind(..)</code> discussion earlier).</p>
<p><code>softBind(..)</code>工具提供的工作方式类似于ES5内置的<code>bind(..)</code> 工具，除了我们的<em>软绑定</em>行为。他包括了指定方法在调用时逻辑上检查<code>this</code>如果是<code>global</code> 或者 <code>undefined</code>，用一个预先各自指定的<em>默认</em>(<code>obj</code>)。否则<code>this</code>就不做改变。他也提供了合适的currying(见我们之前讨论的<code>bind(..)</code>)。</p>
<p>Let’s demonstrate its usage:</p>
<p>让我们来演示他的用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</span><br><span class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</span><br><span class="line"></span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line"></span><br><span class="line">obj2.foo = foo.softBind(obj);</span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2   &lt;---- look!!!</span></span><br><span class="line"></span><br><span class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3   &lt;---- look!</span></span><br><span class="line"></span><br><span class="line">setTimeout( obj2.foo, <span class="number">10</span> ); <span class="comment">// name: obj   &lt;---- falls back to soft-binding</span></span><br></pre></td></tr></table></figure>
<p>The soft-bound version of the <code>foo()</code> function can be manually <code>this</code>-bound to <code>obj2</code> or <code>obj3</code> as shown, but it falls back to <code>obj</code> if the <em>default binding</em> would otherwise apply.</p>
<p>软绑定版本的<code>foo()</code>方法可以像看到的那样手动绑定 <code>this</code>到<code>obj2</code> 或者 <code>obj3</code>，同时如果是<em>默认绑定</em>应用也可以退回到<code>obj</code>。</p>
<h2 id="Lexical-this"><a href="#Lexical-this" class="headerlink" title="Lexical this"></a>Lexical <code>this</code></h2><h2 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法<code>this</code></h2><p>Normal functions abide by the 4 rules we just covered. But ES6 introduces a special kind of function that does not use these rules: arrow-function.</p>
<p>普通方法遵循4种规则我们已经都讲了。但是ES6介绍了一种特别的方法不能使用这些规则:箭头方法。</p>
<p>Arrow-functions are signified not by the <code>function</code> keyword, but by the <code>=&gt;</code> so called “fat arrow” operator. Instead of using the four standard <code>this</code> rules, arrow-functions adopt the <code>this</code> binding from the enclosing (function or global) scope.</p>
<p>箭头方法声明不是使用<code>function</code>关键字，使用<code>=&gt;</code>所以被称作”箭头”操作符。使用4种标准的规则不同的是，箭头方法从包围的(方法或者全局)作用域接受<code>this</code>绑定。</p>
<p>Let’s illustrate arrow-function lexical scope:</p>
<p>让我们距离说明一下箭头方法的词法作用域:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// return an arrow function</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// `this` here is lexically adopted from `foo()`</span></span><br><span class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); <span class="comment">// 2, not 3!</span></span><br></pre></td></tr></table></figure>
<p>The arrow-function created in <code>foo()</code> lexically captures whatever <code>foo()</code>s <code>this</code> is at its call-time. Since <code>foo()</code> was <code>this</code>-bound to <code>obj1</code>, <code>bar</code> (a reference to the returned arrow-function) will also be <code>this</code>-bound to <code>obj1</code>. The lexical binding of an arrow-function cannot be overridden (even with <code>new</code>!).</p>
<p>箭头函数在<code>foo()</code> 词法作用域中被创建捕获 <code>foo()</code>的<code>this</code>在他执行的时候。一旦 <code>foo()</code> 绑定将<code>this</code>到<code>obj1</code>，<code>bar</code>(一个箭头函数被返回)将也会将<code>this</code>绑定到 <code>obj1</code>。箭头函数的词法绑定不能被重写(即使是使用<code>new</code>!)。</p>
<p>The most common use-case will likely be in the use of callbacks, such as event handlers or timers:</p>
<p>最常见的使用场景是使用在回调中，类似事件控制器或者事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// `this` here is lexically adopted from `foo()`</span></span><br><span class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">	&#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>While arrow-functions provide an alternative to using <code>bind(..)</code> on a function to ensure its <code>this</code>, which can seem attractive, it’s important to note that they essentially are disabling the traditional <code>this</code> mechanism in favor of more widely-understood lexical scoping. Pre-ES6, we already have a fairly common pattern for doing so, which is basically almost indistinguishable from the spirit of ES6 arrow-functions:</p>
<p>箭头函数提供了一个可以替代在方法上使用<code>bind(..)</code>的方式来确保<code>this</code>，这看起来挺招人喜欢，需要重点注意的是他本质上禁用了传统的<code>this</code>机制而采用了更广为人知的词法作用域。ES6之前我们已经有了相当普通的模式来这样做，基本上几乎和ES6的箭头方法的精神一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// lexical capture of `this`</span></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( self.a );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>While <code>self = this</code> and arrow-functions both seem like good “solutions” to not wanting to use <code>bind(..)</code>, they are essentially fleeing from <code>this</code> instead of understanding and embracing it.</p>
<p>而<code>self = this</code> 和箭头函数在你不想使用 <code>bind(..)</code>的时候看起来都像是好的”解决方案”，他们本质上是逃避<code>this</code>而不是理解和拥抱他。</p>
<p>If you find yourself writing <code>this</code>-style code, but most or all the time, you defeat the <code>this</code> mechanism with lexical <code>self = this</code> or arrow-function “tricks”, perhaps you should either:</p>
<p>如果你发现你自己写<code>this</code>风格的代码，但是大多数或者全部时候，你使用词法<code>self = this</code> 或者箭头函数”把戏”来击败 <code>this</code>机制，也许你也可以选择:</p>
<ol>
<li><p>Use only lexical scope and forget the false pretense of <code>this</code>-style code.</p>
</li>
<li><p>只使用词法作用域然后忘掉<code>this</code>风格代码的错误模式.</p>
</li>
<li><p>Embrace <code>this</code>-style mechanisms completely, including using <code>bind(..)</code> where necessary, and try to avoid <code>self = this</code> and arrow-function “lexical this” tricks.</p>
</li>
<li><p>完全拥抱<code>this</code>风格的机制，包括在需要的时候使用<code>bind(..)</code>，然后尝试避免<code>self = this</code>和箭头函数”词法this”的把戏。</p>
</li>
</ol>
<p>A program can effectively use both styles of code (lexical and <code>this</code>), but inside of the same function, and indeed for the same sorts of look-ups, mixing the two mechanisms is usually asking for harder-to-maintain code, and probably working too hard to be clever.</p>
<p>一个程序可以有效的同时使用两种风格的代码(词法和<code>this</code>)，但是在同一个方法的内部，和同种类型的查看，混合两种机制通常会带来难以维护的代码，很有可能是工作变的艰难。</p>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><h2 id="回顾-TL-DR"><a href="#回顾-TL-DR" class="headerlink" title="回顾(TL;DR)"></a>回顾(TL;DR)</h2><p>Determining the <code>this</code> binding for an executing function requires finding the direct call-site of that function. Once examined, four rules can be applied to the call-site, in <em>this</em> order of precedence:</p>
<p>一个执行的方法查明<code>this</code>绑定需要找到方法的调用位置。一个个的检查，4个规则可以被应用于调用位置，他们有这样的优先顺序:</p>
<ol>
<li><p>Called with <code>new</code>? Use the newly constructed object.</p>
</li>
<li><p>通过<code>new</code>调用？用新创建的对象。</p>
</li>
<li><p>Called with <code>call</code> or <code>apply</code> (or <code>bind</code>)? Use the specified object.</p>
</li>
<li><p>通过 <code>call</code> 或者 <code>apply</code> (或者 <code>bind</code>)调用？使用指定的对象。</p>
</li>
<li><p>Called with a context object owning the call? Use that context object.</p>
</li>
<li><p>通过一个上下文对象自己调用?使用这个上下文对象。</p>
</li>
<li><p>Default: <code>undefined</code> in <code>strict mode</code>, global object otherwise.</p>
</li>
<li><p>默认:<code>strict mode</code>(严格模式)下为<code>undefined</code>,此外是global对象。</p>
</li>
</ol>
<p>Be careful of accidental/unintentional invoking of the <em>default binding</em> rule. In cases where you want to “safely” ignore a <code>this</code> binding, a “DMZ” object like <code>ø = Object.create(null)</code> is a good placeholder value that protects the <code>global</code> object from unintended side-effects.</p>
<p>有意/无意执行<em>默认绑定</em>时要小心。当你想”更安全”的忽略一个 <code>this</code>绑定的情况下，一个”DMZ”对象类似<code>ø = Object.create(null)</code> 是一个好的占位值他可以保护无意间使用<code>global</code>对象带来的不好的影响。</p>
<p>Instead of the four standard binding rules, ES6 arrow-functions use lexical scoping for <code>this</code> binding, which means they adopt the <code>this</code> binding (whatever it is) from its enclosing function call. They are essentially a syntactic replacement of <code>self = this</code> in pre-ES6 coding.</p>
<p>和4种标准的绑定规则不同，ES6箭头函数使用词法作用域作为<code>this</code>绑定，这意味着他们从包围的方法调用中获取<code>this</code>绑定。在ES6之前这本质上在可以通过 <code>self = this</code>这种句法上来替代。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/29/You-Don-t-Know-JS-this-Object-Prototypes-Chapter-2-this-All-Makes-Sense-Now/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-You-Don-t-Know-JS-this-Object-Prototypes-Chapter-1-this-Or-That" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/You-Don-t-Know-JS-this-Object-Prototypes-Chapter-1-this-Or-That/">You Don&#39;t Know JS: this &amp; Object Prototypes-Chapter 1: this Or That?</a>
    </h1>
  

        
        <a href="/2017/07/29/You-Don-t-Know-JS-this-Object-Prototypes-Chapter-1-this-Or-That/" class="archive-article-date">
  	<time datetime="2017-07-29T04:18:17.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="You-Don’t-Know-JS-this-amp-Object-Prototypes"><a href="#You-Don’t-Know-JS-this-amp-Object-Prototypes" class="headerlink" title="You Don’t Know JS: this &amp; Object Prototypes"></a>You Don’t Know JS: <em>this</em> &amp; Object Prototypes</h1><h1 id="Chapter-1-this-Or-That"><a href="#Chapter-1-this-Or-That" class="headerlink" title="Chapter 1: this Or That?"></a>Chapter 1: <code>this</code> Or That?</h1><h1 id="你不知道的JS：-this-amp-Object-Prototypes"><a href="#你不知道的JS：-this-amp-Object-Prototypes" class="headerlink" title="你不知道的JS： this &amp; Object Prototypes"></a>你不知道的JS： <em>this</em> &amp; Object Prototypes</h1><h1 id="第一章-this-或者-That"><a href="#第一章-this-或者-That" class="headerlink" title="第一章: this 或者 That?"></a>第一章: <code>this</code> 或者 That?</h1><p>One of the most confused mechanisms in JavaScript is the <code>this</code> keyword. It’s a special identifier keyword that’s automatically defined in the scope of every function, but what exactly it refers to bedevils even seasoned JavaScript developers.</p>
<p>JavaScript中最令人困惑的其中之一机制就是<code>this</code>关键字。这是一个特别的标识符关键字他会自动在每一个方法作用域中定义，但是他到底引用着什么长期困扰着JavaScript开发者甚至是老练的开发者。</p>
<blockquote>
<p>Any sufficiently <em>advanced</em> technology is indistinguishable from magic. – Arthur C. Clarke</p>
</blockquote>
<blockquote>
<p>任何足够的<em>先进</em>的技术和魔法没什么区别。 – Arthur C. Clarke</p>
</blockquote>
<p>JavaScript’s <code>this</code> mechanism isn’t actually <em>that</em> advanced, but developers often paraphrase that quote in their own mind by inserting “complex” or “confusing”, and there’s no question that without lack of clear understanding, <code>this</code> can seem downright magical in <em>your</em> confusion.</p>
<p>JavaScript的<code>this</code>机制并没有真正的<em>那么</em>高级，但是开发者经常将那个引用解释就好像在他们的脑子里插入了”复杂”或者”疑惑”，缺乏了清楚的理解，<code>this</code>在<em>你的</em>疑惑里看起来就像是个十足的魔法这点事毫无疑问的。</p>
<p><strong>Note:</strong> The word “this” is a terribly common pronoun in general discourse. So, it can be very difficult, especially verbally, to determine whether we are using “this” as a pronoun or using it to refer to the actual keyword identifier. For clarity, I will always use <code>this</code> to refer to the special keyword, and “this” or <em>this</em> or this otherwise.</p>
<p><strong>注意:</strong> 单词”this”在现代话语里是一个非常常见的发音。所以，不论是用”this”作为发音或者用它来引用一个真正的关键字标识符，这个可以非常难，特别是口头。为了更清楚，我将会使用<code>this</code>来引用一个特殊的关键字，除此之外用”this” 或者 <em>this</em> 或者 this。</p>
<h2 id="Why-this"><a href="#Why-this" class="headerlink" title="Why this?"></a>Why <code>this</code>?</h2><h2 id="为什么this"><a href="#为什么this" class="headerlink" title="为什么this?"></a>为什么<code>this</code>?</h2><p>If the <code>this</code> mechanism is so confusing, even to seasoned JavaScript developers, one may wonder why it’s even useful? Is it more trouble than it’s worth? Before we jump into the <em>how</em>, we should examine the <em>why</em>.</p>
<p>如果<code>this</code>机制是那么的令人疑惑，即使是老练的JavaScript开发者，你可能会好奇为什么他还那么有用?他会带来更多的麻烦还是益处？在我们跳到<em>如何</em>之前，我们需要搞清楚<em>为什么</em>。</p>
<p>Let’s try to illustrate the motivation and utility of <code>this</code>:</p>
<p>让我们来试图举例说明<code>this</code>的行为动机(motivation:to be the reason why sth in a particular way)和用处：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify.call( <span class="keyword">this</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">	name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">	name: <span class="string">"Reader"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.call( me ); <span class="comment">// KYLE</span></span><br><span class="line">identify.call( you ); <span class="comment">// READER</span></span><br><span class="line"></span><br><span class="line">speak.call( me ); <span class="comment">// Hello, I'm KYLE</span></span><br><span class="line">speak.call( you ); <span class="comment">// Hello, I'm READER</span></span><br></pre></td></tr></table></figure>
<p>If the <em>how</em> of this snippet confuses you, don’t worry! We’ll get to that shortly. Just set those questions aside briefly so we can look into the <em>why</em> more clearly.</p>
<p>如果这个段代码<em>如果工作</em>的使你迷惑，别担心！你马上就会知道。先将这些问题短暂的放在一边这样我们可以把<em>为什么</em>看的更清楚。</p>
<p>This code snippet allows the <code>identify()</code> and <code>speak()</code> functions to be re-used against multiple <em>context</em> (<code>me</code> and <code>you</code>) objects, rather than needing a separate version of the function for each object.</p>
<p>这段代码允许<code>identify()</code> 和 <code>speak()</code>方法重复使用多个<em>上下文环境</em>(<code>me</code> 和 <code>you</code>)对象，而不是需要对每个对象有一个独立版本的方法。</p>
<p>Instead of relying on <code>this</code>, you could have explicitly passed in a context object to both <code>identify()</code> and <code>speak()</code>.</p>
<p>你可以明确的传入一个上下文对象给<code>identify()</code> 和 <code>speak()</code>，来代替依赖<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify( context );</span><br><span class="line">	<span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify( you ); <span class="comment">// READER</span></span><br><span class="line">speak( me ); <span class="comment">// Hello, I'm KYLE</span></span><br></pre></td></tr></table></figure>
<p>However, the <code>this</code> mechanism provides a more elegant way of implicitly “passing along” an object reference, leading to cleaner API design and easier re-use.</p>
<p>然而，<code>this</code>机制提供了一个更优雅的方式来隐晦的<em>传递</em>一个对象的引用，使API更清爽更易复用。</p>
<p>The more complex your usage pattern is, the more clearly you’ll see that passing context around as an explicit parameter is often messier than passing around a <code>this</code> context. When we explore objects and prototypes, you will see the helpfulness of a collection of functions being able to automatically reference the proper context object.</p>
<p>你使用的模式越复杂，你就会越清楚的看到，传递上下文作为明确的参数通常比传递一个<code>this</code>上下文来的更混乱。当我们开始探索对象和原型，你将会看到一个方法集合能够自动引用合适的上下文对象是多么有用。</p>
<h2 id="Confusions"><a href="#Confusions" class="headerlink" title="Confusions"></a>Confusions</h2><h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>We’ll soon begin to explain how <code>this</code> <em>actually</em> works, but first we must  dispel some misconceptions about how it <em>doesn’t</em> actually work.</p>
<p>我们将很快开始探索<code>this</code><em>实际上</em> 是如何工作的，但是首先我们必须消除一些错误的观念关于他实际上<em>不是</em>如何工作的。</p>
<p>The name “this” creates confusion when developers try to think about it too literally. There are two meanings often assumed, but both are incorrect.</p>
<p>当开发人员试图把”this”想的太字面化这个名字会产生混淆。有两种意思经常被假设，但是他们都是不正确的。</p>
<h3 id="Itself"><a href="#Itself" class="headerlink" title="Itself"></a>Itself</h3><h3 id="他自己"><a href="#他自己" class="headerlink" title="他自己"></a>他自己</h3><p>The first common temptation is to assume <code>this</code> refers to the function itself. That’s a reasonable grammatical inference, at least.</p>
<p>第一种常见的诱导是假设<code>this</code>引用的方法本身。至少这是一个有原因的符合语法的推论。</p>
<p>Why would you want to refer to a function from inside itself? The most common reasons would be things like recursion (calling a function from inside itself) or having an event handler that can unbind itself when it’s first called.</p>
<p>为什么你希望一个方法从内部引用他自己？最常见的原因将会类似重复调用(从方法内部调用自己)或者一个事件管理器可以自己在第一次执行的解绑自己。</p>
<p>Developers new to JS’s mechanisms often think that referencing the function as an object (all functions in JavaScript are objects!) lets you store <em>state</em> (values in properties) between function calls. While this is certainly possible and has some limited uses, the rest of the book will expound on many other patterns for <em>better</em> places to store state besides the function object.</p>
<p>开发者一开始接触JS的机制经常会引用方法作为一个对象(所有的方法在JavaScript中都是对象！)让你在方法调用时存储<em>状态</em>(将方法存储在属性上)。然而这确实是有可能的还有一些受局限的用处，书的剩下部分将会详细解释许多其他的模式在方法对象之间提供<em>更好</em>的地方来存储状态。</p>
<p>But for just a moment, we’ll explore that pattern, to illustrate how <code>this</code> doesn’t let a function get a reference to itself like we might have assumed.</p>
<p>但是给一点时间，我们将会探索那个模式，来举例说明<code>this</code>如何不会像我们假设的那样让一个方法获得他本身的引用。</p>
<p>Consider the following code, where we attempt to track how many times a function (<code>foo</code>) was called:</p>
<p>考虑一下接下来打代码，我们试图来跟踪一个方法(<code>foo</code>)被调用了几次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep track of how many times `foo` is called</span></span><br><span class="line">	<span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// how many times was `foo` called?</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>
<p><code>foo.count</code> is <em>still</em> <code>0</code>, even though the four <code>console.log</code> statements clearly indicate <code>foo(..)</code> was in fact called four times. The frustration stems from a <em>too literal</em> interpretation of what <code>this</code> (in <code>this.count++</code>) means.</p>
<p><code>foo.count</code><em>仍然</em> 是0，即使通过了四次<code>console.log</code>表达式清楚的指出了<code>foo(..)</code>事实上被调用了四次。这个令人沮丧的根源是对(<code>this.count++</code>的)<code>this</code>的解释<em>太过于字面化</em>。</p>
<p>When the code executes <code>foo.count = 0</code>, indeed it’s adding a property <code>count</code> to the function object <code>foo</code>. But for the <code>this.count</code> reference inside of the function, <code>this</code> is not in fact pointing <em>at all</em> to that function object, and so even though the property names are the same, the root objects are different, and confusion ensues.</p>
<p>当代码执行<code>foo.count = 0</code>，事实上是将一个属性<code>count</code>附加到方法对象<code>foo</code>上。但是<code>this.count</code>引用在方法的内部，<code>this</code>事实上<em>根本</em>不是指向的方法对象，所以即使属性名称相同，根本的对象还是不一样，因此产生了混淆。</p>
<p><strong>Note:</strong> A responsible developer <em>should</em> ask at this point, “If I was incrementing a <code>count</code> property but it wasn’t the one I expected, which <code>count</code> <em>was</em> I incrementing?” In fact, were she to dig deeper, she would find that she had accidentally created a global variable <code>count</code> (see Chapter 2 for <em>how</em> that happened!), and it currently has the value <code>NaN</code>. Of course, once she identifies this peculiar outcome, she then has a whole other set of questions: “How was it global, and why did it end up <code>NaN</code> instead of some proper count value?” (see Chapter 2).</p>
<p><strong>注意:</strong> 一个负责的开发者<em>应该</em>问这么个问题，”如果我增加的<code>count</code>属性并不是一个我期望增加的一个属性，哪个<code>count</code>才是我增加的？”事实上，如果他挖的更深入一点，他会发现他意外的创建了一个全局变量<code>count</code>(他是如何发生的见第二章)，现在的值是<code>NaN</code>。当然，一旦他意识到了这个奇怪的结果，他接下来会有一堆其他的问题:”为什么是全局,为什么他最后是<code>NaN</code>而不是其他更合适的可数值？”(见第二章)。</p>
<p>Instead of stopping at this point and digging into why the <code>this</code> reference doesn’t seem to be behaving as <em>expected</em>, and answering those tough but important questions, many developers simply avoid the issue altogether, and hack toward some other solution, such as creating another object to hold the <code>count</code> property:</p>
<p>相反的停止这个相反然后去深究为什么<code>this</code>引用似乎跟<em>期望</em>的举止不太一样，然后回答这些困难而且重要的问题，许多开发者会简单的回避这些问题，然后开辟出其他的解决方案，类似创建另外对象来保存<code>count</code>属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep track of how many times `foo` is called</span></span><br><span class="line">	data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">	count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// how many times was `foo` called?</span></span><br><span class="line"><span class="built_in">console</span>.log( data.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>While it is true that this approach “solves” the problem, unfortunately it simply ignores the real problem – lack of understanding what <code>this</code> means and how it works – and instead falls back to the comfort zone of a more familiar mechanism: lexical scope.</p>
<p>虽然这的确”解决”问题的一种类似方式，不幸的是这让你忽略了真正的问题 – 对<code>this</code>是什么意思以及他是如何工作的的缺乏理解 – 相反的退回到舒适区使用更熟悉的机制:词法作用域。</p>
<p><strong>Note:</strong> Lexical scope is a perfectly fine and useful mechanism; I am not belittling the use of it, by any means (see <em>“Scope &amp; Closures”</em> title of this book series). But constantly <em>guessing</em> at how to use <code>this</code>, and usually being <em>wrong</em>, is not a good reason to retreat back to lexical scope and never learn <em>why</em> <code>this</code> eludes you.</p>
<p><strong>注意:</strong> 词法作用域是一个非常好并且有用的机制;我无论如何不是贬低他的用处(见 这个系列的<em>“作用域&amp;闭包”</em> 标头 )。但是不断的<em>猜测</em>如何使用<code>this</code>，这经常会<em>犯错</em>，这不是一个好的理由来撤退回词法作用域然后永远不学<em>为什么</em><code>this</code>总是不按照你说的做。(eludes you:you are not able to achieve it.)</p>
<p>To reference a function object from inside itself, <code>this</code> by itself will typically be insufficient. You generally need a reference to the function object via a lexical identifier (variable) that points at it.</p>
<p>从方法内部引用一个方法对象，<code>this</code>理解为他本身通常是不充分的。你通常需要经由一个词法标识符(变量)来引用一个方法。</p>
<p>Consider these two functions:</p>
<p>考虑这两个方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	foo.count = <span class="number">4</span>; <span class="comment">// `foo` refers to itself</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// anonymous function (no name), cannot</span></span><br><span class="line">	<span class="comment">// refer to itself</span></span><br><span class="line">&#125;, <span class="number">10</span> );</span><br></pre></td></tr></table></figure>
<p>In the first function, called a “named function”, <code>foo</code> is a reference that can be used to refer to the function from inside itself.</p>
<p>第一个方法，被叫做”有名字的方法”，<code>foo</code>可以使用来从方法内部引用方法的一个引用。</p>
<p>But in the second example, the function callback passed to <code>setTimeout(..)</code> has no name identifier (so called an “anonymous function”), so there’s no proper way to refer to the function object itself.</p>
<p>但是第二个例子，传入到<code>setTimeout(..)</code>的回调方法是没有名字标识符的(所以被叫做”匿名方法”)，所以没有合适的方法来引用方法对象本身。</p>
<p><strong>Note:</strong> The old-school but now deprecated and frowned-upon <code>arguments.callee</code> reference inside a function <em>also</em> points to the function object of the currently executing function. This reference is typically the only way to access an anonymous function’s object from inside itself. The best approach, however, is to avoid the use of anonymous functions altogether, at least for those which require a self-reference, and instead use a named function (expression). <code>arguments.callee</code> is deprecated and should not be used.</p>
<p><strong>注意:</strong> <code>arguments.callee</code>是老式而且现在已经不被推荐而且让人皱眉的引用它在一个方法内部<em>仍然</em>指向当前执行方法的方法对象。这个引用通常是唯一一种可以从匿名方法内部读取方法对象的方式。最接近的方式，然而，总而言之还是要避免使用匿名方法，至少对于那些需要自己引用自己的方法来说，可以相反的使用有名字的方法(表达式)。<code>arguments.callee</code>是不被推荐的应该不要使用。</p>
<p>So another solution to our running example would have been to use the <code>foo</code> identifier as a function object reference in each place, and not use <code>this</code> at all, which <em>works</em>:</p>
<p>所以让我们的例子能够工作的其他的解决方案是使用<code>foo</code>标识符作为一个方法的引用在每个地方使用，完全不使用<code>this</code>，也可以<em>工作</em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep track of how many times `foo` is called</span></span><br><span class="line">	foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		foo( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// how many times was `foo` called?</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>However, that approach similarly side-steps <em>actual</em> understanding of <code>this</code> and relies entirely on the lexical scoping of variable <code>foo</code>.</p>
<p>然而，这种处理方式就是类似回避了<em>真正</em>理解<code>this</code>然后完全依赖词法作用域的变量<code>foo</code>。</p>
<p>Yet another way of approaching the issue is to force <code>this</code> to actually point at the <code>foo</code> function object:</p>
<p>处理这个问题的另外一个方式是强迫<code>this</code>真正的指向<code>foo</code>方法对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep track of how many times `foo` is called</span></span><br><span class="line">	<span class="comment">// Note: `this` IS actually `foo` now, based on</span></span><br><span class="line">	<span class="comment">// how `foo` is called (see below)</span></span><br><span class="line">	<span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="comment">// using `call(..)`, we ensure the `this`</span></span><br><span class="line">		<span class="comment">// points at the function object (`foo`) itself</span></span><br><span class="line">		foo.call( foo, i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// how many times was `foo` called?</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><strong>Instead of avoiding <code>this</code>, we embrace it.</strong> We’ll explain in a little bit <em>how</em> such techniques work much more completely, so don’t worry if you’re still a bit confused!</p>
<p><strong>相反的回避<code>this</code>，我们选择拥抱他。</strong> 我们将会对类似这样的技巧是如何工作的进行一点解释让他有更完整的解释，所以如果你仍然还有一点疑惑不要担心！</p>
<h3 id="Its-Scope"><a href="#Its-Scope" class="headerlink" title="Its Scope"></a>Its Scope</h3><h3 id="他的作用域"><a href="#他的作用域" class="headerlink" title="他的作用域"></a>他的作用域</h3><p>The next most common misconception about the meaning of <code>this</code> is that it somehow refers to the function’s scope. It’s a tricky question, because in one sense there is some truth, but in the other sense, it’s quite misguided.</p>
<p>下一个关于<code>this</code>的意思最常见的错误观念是 <code>this</code>以某种方式引用方法的作用域。这是一个棘手的问题，因为有一个意思他是对的，但是另外一个意思，他完全是被误导的。</p>
<p>To be clear, <code>this</code> does not, in any way, refer to a function’s <strong>lexical scope</strong>. It is true that internally, scope is kind of like an object with properties for each of the available identifiers. But the scope “object” is not accessible to JavaScript code. It’s an inner part of the <em>Engine</em>‘s implementation.</p>
<p>说的更清楚一些,<code>this</code>不管以何种方式都不会是对一个方法的<strong>词法作用域</strong>的引用。在内部他是对的，作用域是一种类似一个将各种标识符作为属性的对象。但是作用域”对象”对JavaScript代码来说是不可读取的、他是一个<em>引擎</em>的内部工具。</p>
<p>Consider code which attempts (and fails!) to cross over the boundary and use <code>this</code> to implicitly refer to a function’s lexical scope:</p>
<p>考虑这个代码它试图(然后失败)穿过边界然后使用<code>this</code>隐晦的引用一个方法的词法作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>There’s more than one mistake in this snippet. While it may seem contrived, the code you see is a distillation of actual real-world code that has been exchanged in public community help forums. It’s a wonderful (if not sad) illustration of just how misguided <code>this</code> assumptions can be.</p>
<p>这个代码片段有不止一处的错误。虽然这可能看起来是人为的，但你看到的代码是一个真正的从公开社区互助讨论区里截取来的代码。这个是可以很好的用来举例说明对<code>this</code>的假设是如何误导的。</p>
<p>Firstly, an attempt is made to reference the <code>bar()</code> function via <code>this.bar()</code>. It is almost certainly an <em>accident</em> that it works, but we’ll explain the <em>how</em> of that shortly. The most natural way to have invoked <code>bar()</code> would have been to omit the leading <code>this.</code> and just make a lexical reference to the identifier.</p>
<p>首先一个尝试通过<code>this.bar()</code>来引用<code>bar()</code>方法。这个几乎可以确定是 <em>意外</em> 它居然成功了，但是我们将简短的解释他是<em>如何</em>成功的。调用<code>bar()</code>最自然的方式是通过忽略开始的<code>this.</code>然后只需要创建一个对标识符的词法引用。</p>
<p>However, the developer who writes such code is attempting to use <code>this</code> to create a bridge between the lexical scopes of <code>foo()</code> and <code>bar()</code>, so that <code>bar()</code> has access to the variable <code>a</code> in the inner scope of <code>foo()</code>. <strong>No such bridge is possible.</strong> You cannot use a <code>this</code> reference to look something up in a lexical scope. It is not possible.</p>
<p>然而，写类似代码的开发者尝试使用<code>this</code>来创建一个位于<code>foo()</code>和<code>bar()</code>词法作用域的桥，所以<code>bar()</code>可以在<code>foo()</code>的内部作用域读取变量<code>a</code>。<strong>这样的桥是不存在的</strong> 你不可以在一个在词法作用域中用<code>this</code>引用来查找东西。这是不可能的。</p>
<p>Every time you feel yourself trying to mix lexical scope look-ups with <code>this</code>, remind yourself: <em>there is no bridge</em>.</p>
<p>每次你感觉你自己尝试使用<code>this</code>在混合的词法作用域中查找，提醒你自己: <em>他们之间没有桥</em>。</p>
<h2 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s <code>this</code>?</h2><h2 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this?"></a>什么是<code>this</code>?</h2><p>Having set aside various incorrect assumptions, let us now turn our attention to how the <code>this</code> mechanism really works.</p>
<p>将各种不正确的假设放在一边，让我们现在把我们的注意力转到<code>this</code>机制真正是如何工作的上面来。</p>
<p>We said earlier that <code>this</code> is not an author-time binding but a runtime binding. It is contextual based on the conditions of the function’s invocation. <code>this</code> binding has nothing to do with where a function is declared, but has instead everything to do with the manner in which the function is called.</p>
<p>我们之前说过<code>this</code>不是一个书写时绑定而是一个运行的绑定。他是以方法调用环境上下文为基础的。<code>this</code>绑定跟放在在哪里调用无关，但是相反的和方法被什么调用有关。</p>
<p>When a function is invoked, an activation record, otherwise known as an execution context, is created. This record contains information about where the function was called from (the call-stack), <em>how</em> the function was invoked, what parameters were passed, etc. One of the properties of this record is the <code>this</code> reference which will be used for the duration of that function’s execution.</p>
<p>当一个方法被调用，会创建一个激活记录，另外也被叫做一个执行上下文。这个记录包含的信息有方法从哪里被调用(调用堆栈)，方法<em>如何</em>被调用，什么参数被传入，等等。这个记录的其中一个属性是<code>this</code>引用他将会在方法的执行期间被使用。</p>
<p>In the next chapter, we will learn to find a function’s <strong>call-site</strong> to determine how its execution will bind <code>this</code>.</p>
<p>在下一章，我们会学习找到一个方法的<strong>调用位置</strong>来确定执行将会如何绑定<code>this</code>。</p>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><h2 id="复习-TL-DR"><a href="#复习-TL-DR" class="headerlink" title="复习 (TL;DR)"></a>复习 (TL;DR)</h2><p><code>this</code> binding is a constant source of confusion for the JavaScript developer who does not take the time to learn how the mechanism actually works. Guesses, trial-and-error, and blind copy-n-paste from Stack Overflow answers is not an effective or proper way to leverage <em>this</em> important <code>this</code> mechanism.</p>
<p><code>this</code>绑定对那些没有花时间去学习这个机制是如何真正工作的人来说是会一直困惑的。猜测，实验然后出错，闭着眼睛从Stack Overflow拷贝粘贴不是一个有效或者更好的方式来利用这个重要的 <code>this</code> 机制。</p>
<p>To learn <code>this</code>, you first have to learn what <code>this</code> is <em>not</em>, despite any assumptions or misconceptions that may lead you down those paths. <code>this</code> is neither a reference to the function itself, nor is it a reference to the function’s <em>lexical</em> scope.</p>
<p>要学<code>this</code>，你首先要学<code>this</code>不是什么，不管哪种假设或者错误的观点可能会使你走到错误的路上。<code>this</code>既不是对方法自己的一个引用，也不是对方法的<em>词法</em>作用域的一个引用。</p>
<p><code>this</code> is actually a binding that is made when a function is invoked, and <em>what</em> it references is determined entirely by the call-site where the function is called.</p>
<p><code>this</code>实际上是当方法被执行时进行的绑定，而他引用着什么整个取决于调用的位置也就是方法在哪里被执行。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/29/You-Don-t-Know-JS-this-Object-Prototypes-Chapter-1-this-Or-That/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-You-Don-t-Know-JS-Scope-Closures-Chapter-5-Scope-Closure" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-5-Scope-Closure/">You Don&#39;t Know JS: Scope &amp; Closures</a>
    </h1>
  

        
        <a href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-5-Scope-Closure/" class="archive-article-date">
  	<time datetime="2017-07-29T04:18:17.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="You-Don’t-Know-JS-Scope-amp-Closures"><a href="#You-Don’t-Know-JS-Scope-amp-Closures" class="headerlink" title="You Don’t Know JS: Scope &amp; Closures"></a>You Don’t Know JS: Scope &amp; Closures</h1><h1 id="Chapter-5-Scope-Closure"><a href="#Chapter-5-Scope-Closure" class="headerlink" title="Chapter 5: Scope Closure"></a>Chapter 5: Scope Closure</h1><h1 id="你不知道的JS：作用域-amp-闭包"><a href="#你不知道的JS：作用域-amp-闭包" class="headerlink" title="你不知道的JS：作用域 &amp; 闭包"></a>你不知道的JS：作用域 &amp; 闭包</h1><h1 id="第五章：作用域闭包"><a href="#第五章：作用域闭包" class="headerlink" title="第五章：作用域闭包"></a>第五章：作用域闭包</h1><p>We arrive at this point with hopefully a very healthy, solid understanding of how scope works.</p>
<p>我们希望我们能带着健全，扎实的对作用域如何工作的理解来带这里。</p>
<p>We turn our attention to an incredibly important, but persistently elusive, <em>almost mythological</em>, part of the language: <strong>closure</strong>. If you have followed our discussion of lexical scope thus far, the payoff is that closure is going to be, largely, anticlimactic, almost self-obvious. <em>There’s a man behind the wizard’s curtain, and we’re about to see him</em>. No, his name is not Crockford!</p>
<p>我们把注意力转到一个极其重要，但是反复出现且难以察觉，几乎是语言神话般的一部分:<strong>闭包</strong>。如果你关注了我们到目前为止对词法作用域的讨论，结果就是闭包将会变的有些扫兴，几乎是显而易见的。<em>一个男人躲在巫师的窗帘后面，我们要去见他</em>。不他的名字不是Crockford。</p>
<p>If however you have nagging questions about lexical scope, now would be a good time to go back and review Chapter 2 before proceeding.</p>
<p>然而如果你有一些关于词法作用域难以搞懂的问题，现在在处理之前会是一个好时机去回顾第二章的内容。</p>
<h2 id="Enlightenment"><a href="#Enlightenment" class="headerlink" title="Enlightenment"></a>Enlightenment</h2><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>For those who are somewhat experienced in JavaScript, but have perhaps never fully grasped the concept of closures, <em>understanding closure</em> can seem like a special nirvana that one must strive and sacrifice to attain.</p>
<p>对那些稍微对JavaScript有点经验的人，但是也许从来没有完全领悟闭包概念的人，<em>理解闭包</em> 似乎有点像一个我们必须努力和牺牲去达到的特别的境界。</p>
<p>I recall years back when I had a firm grasp on JavaScript, but had no idea what closure was. The hint that there was <em>this other side</em> to the language, one which promised even more capability than I already possessed, teased and taunted me. I remember reading through the source code of early frameworks trying to understand how it actually worked. I remember the first time something of the “module pattern” began to emerge in my mind. I remember the <em>a-ha!</em> moments quite vividly.</p>
<p>我回忆几年之前当我对JavaScript掌握的挺扎实，但我还是不知道闭包是什么。这暗示着语言的<em>另外一边</em>，他承诺了比我准备处理的更多的能力，取笑和戏弄我。我记得我通过读早起框架的源代码来试图理解它实际上是如何工作的。我记得第一次”模块模式的”一些东西开始出现在我脑海里。我记得<em>阿哈</em>的瞬间非常的生动。</p>
<p>What I didn’t know back then, what took me years to understand, and what I hope to impart to you presently, is this secret: <strong>closure is all around you in JavaScript, you just have to recognize and embrace it.</strong> Closures are not a special opt-in tool that you must learn new syntax and patterns for. No, closures are not even a weapon that you must learn to wield and master as Luke trained in The Force.</p>
<p>什么是我那个时候不知道的，什么让我花了几年的时间来理解，什么是我希望最先传授给你的，是这个秘密：<strong>在JavaScript中到处都有闭包，你只需要认出他然后拥抱他。</strong> 闭包不是一个需要你为他学习新的语法和模式的特别的选择性使用的工具。不，闭包甚至不是一个你必须学着使用的武器也不需要像Luke一样训练像大师一样使用这种武力。</p>
<p>Closures happen as a result of writing code that relies on lexical scope. They just happen. You do not even really have to intentionally create closures to take advantage of them. Closures are created and used for you all over your code. What you are <em>missing</em> is the proper mental context to recognize, embrace, and leverage closures for your own will.</p>
<p>闭包作为书写代码的结果依赖于词法作用域。他就这样发生了。你甚至不是有意的创造了闭包然后在它身上获得益处。闭包在你的代码的各个地方被创建和使用。你缺失是更好的思维环境去识别，拥抱，和影响闭包来做你自己想做的事。</p>
<p>The enlightenment moment should be: <strong>oh, closures are already occurring all over my code, I can finally <em>see</em> them now.</strong> Understanding closures is like when Neo sees the Matrix for the first time.</p>
<p>这个开光的瞬间应该是:<strong>噢，闭包已经在我代码的到处执行了，现在我终于可以<em>看见</em>他*了</strong> 理解闭包就像第一次Neo看见Matrix的时候。</p>
<h2 id="Nitty-Gritty"><a href="#Nitty-Gritty" class="headerlink" title="Nitty Gritty"></a>Nitty Gritty</h2><h2 id="重要细节"><a href="#重要细节" class="headerlink" title="重要细节"></a>重要细节</h2><p>OK, enough hyperbole and shameless movie references.</p>
<p>OK,已经受够了这种夸张且没有羞耻心的电影引用了。</p>
<p>Here’s a down-n-dirty definition of what you need to know to understand and recognize closures:</p>
<p>你需要如何理解和识别闭包,这里是定义</p>
<blockquote>
<p>Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.</p>
</blockquote>
<blockquote>
<p>闭包是当一个方法需要记住和存取这个作用域尽管这个方法在这个作用域的外部执行。</p>
</blockquote>
<p>Let’s jump into some code to illustrate that definition.</p>
<p>让我们跳到某些代码来举例说明这个定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>This code should look familiar from our discussions of Nested Scope. Function <code>bar()</code> has <em>access</em> to the variable <code>a</code> in the outer enclosing scope because of lexical scope look-up rules (in this case, it’s an RHS reference look-up).</p>
<p>经过我们之前讨论的嵌套作用域这个代码应该会看起来有些熟悉。方法<code>bar()</code>有<em>读取</em>在包围作用域外部的变量<code>a</code>因为根据作用域查询规则他可以这么做(在这个例子中，是一个RHS引用查看)。</p>
<p>Is this “closure”?</p>
<p>这就是”闭包”?</p>
<p>Well, technically… <em>perhaps</em>. But by our what-you-need-to-know definition above… <em>not exactly</em>. I think the most accurate way to explain <code>bar()</code> referencing <code>a</code> is via lexical scope look-up rules, and those rules are <em>only</em> (an important!) <strong>part</strong> of what closure is.</p>
<p>恩,技术上来说…<em>也许</em>。但是根据什么是你需要知道关于定义…<em>不准确</em>。我想最准确的方式来解释<code>bar()</code>对<code>a</code>的引用是它根据了词法作用域的查询规则，这些规则<em>只是</em>(一个很重要的)闭包的一部分。</p>
<p>From a purely academic perspective, what is said of the above snippet is that the function <code>bar()</code> has a <em>closure</em> over the scope of <code>foo()</code> (and indeed, even over the rest of the scopes it has access to, such as the global scope in our case). Put slightly differently, it’s said that <code>bar()</code> closes over the scope of <code>foo()</code>. Why? Because <code>bar()</code> appears nested inside of <code>foo()</code>. Plain and simple.</p>
<p>根据一个纯学术的观点，我们说这段代码方法<code>bar()</code>有对于作用域<code>foo()</code>一个闭包(的确，即使是在其余的作用域中还是可以读取，你像我们例子中的全局作用域)。换句略有不同的话来说，<code>bar()</code>关闭了<code>foo()</code>作用域。为什么?因为<code>bar()</code>出现被嵌套在<code>foo()</code>中。简单清楚。</p>
<p>But, closure defined in this way is not directly <em>observable</em>, nor do we see closure <em>exercised</em> in that snippet. We clearly see lexical scope, but closure remains sort of a mysterious shifting shadow behind the code.</p>
<p>但是，闭包被按照这种方式定义就不是直接为<em>可观察</em>了，闭包也不是我们在这段代码中看到的这样使用。我们清楚的看到词法作用域，但是闭包就像是代码背后神秘的快速移动的影子。</p>
<p>Let us then consider code which brings closure into full light:</p>
<p>让我们接下来考虑这段使闭包被照亮显示出来的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- Whoa, closure was just observed, man.</span></span><br></pre></td></tr></table></figure>
<p>The function <code>bar()</code> has lexical scope access to the inner scope of <code>foo()</code>. But then, we take <code>bar()</code>, the function itself, and pass it <em>as</em> a value. In this case, we <code>return</code> the function object itself that <code>bar</code> references.</p>
<p>方法<code>bar()</code>有<code>foo()</code>作用域内部的词法作用域读取权。但是现在,我们得到<code>bar()</code>方法本身，然后把他作为值一样传输。在这个例子中，我们<code>return`</code>bar`方法对象本身的引用。</p>
<p>After we execute <code>foo()</code>, we assign the value it returned (our inner <code>bar()</code> function) to a variable called <code>baz</code>, and then we actually invoke <code>baz()</code>, which of course is invoking our inner function <code>bar()</code>, just by a different identifier reference.</p>
<p>在我们执行了<code>foo()</code>之后，我们把返回回来(我们内部的方法)的值赋值给了一个变量叫做<code>baz</code>，接着我们触发了<code>baz()</code>，事实上就是执行了我们的内部方法 <code>bar()</code>,只不过使用了另外一个标识符引用。</p>
<p><code>bar()</code> is executed, for sure. But in this case, it’s executed <em>outside</em> of its declared lexical scope.</p>
<p>可以肯定的是<code>bar()</code>被执行了。但是在这个例子中，他在声明作用域的<em>外面</em>被执行了。</p>
<p>After <code>foo()</code> executed, normally we would expect that the entirety of the inner scope of <code>foo()</code> would go away, because we know that the <em>Engine</em> employs a <em>Garbage Collector</em> that comes along and frees up memory once it’s no longer in use. Since it would appear that the contents of <code>foo()</code> are no longer in use, it would seem natural that they should be considered <em>gone</em>.</p>
<p><code>foo()</code>被执行后，通常情况下我们会猜想整个<code>foo()</code>作用域内部会释放，因为我们知道<em>引擎</em>使用一个<em>垃圾回收</em>来释放之后都不在使用的内存。因为<code>foo()</code>的内容看起来不在被使用，似乎自然的他应该被认为是<em>消失</em>了。</p>
<p>But the “magic” of closures does not let this happen. That inner scope is in fact <em>still</em> “in use”, and thus does not go away. Who’s using it? <strong>The function <code>bar()</code> itself</strong>.</p>
<p>但是闭包的”魔法”不会让这个发生。内部的作用域实际上<em>仍然</em>“在使用”，所以不能被释放。谁在使用？ <strong>方法<code>bar()</code>本身</strong>。</p>
<p>By virtue of where it was declared, <code>bar()</code> has a lexical scope closure over that inner scope of <code>foo()</code>, which keeps that scope alive for <code>bar()</code> to reference at any later time.</p>
<p>因为他声明的位置，<code>bar()</code>在作用域<code>foo()</code>内部有一个词法作用域闭包，他使那个作用始终存活着为了 <code>bar()</code>能够在后面的时间能够引用。</p>
<p><strong><code>bar()</code> still has a reference to that scope, and that reference is called closure.</strong></p>
<p><strong><code>bar()</code>仍然对那个作用域有一个引用，这个引用被叫做闭包。</strong></p>
<p>So, a few microseconds later, when the variable <code>baz</code> is invoked (invoking the inner function we initially labeled <code>bar</code>), it duly has <em>access</em> to author-time lexical scope, so it can access the variable <code>a</code> just as we’d expect.</p>
<p>所以，几毫秒之后，当变量<code>baz</code>被触发(执行我们初始化标记为<code>bar</code>的内部方法)，他当然有访问书写时词法作用域的权限，所以他可以像我们希望的一样访问变量<code>a</code>。</p>
<p>The function is being invoked well outside of its author-time lexical scope. <strong>Closure</strong> lets the function continue to access the lexical scope it was defined in at author-time.</p>
<p>这个方法在书写时词法作用域的外面仍然可以被执行。<strong>闭包</strong> 使方法可以继续读取在书写时定义的词法作用域。</p>
<p>Of course, any of the various ways that functions can be <em>passed around</em> as values, and indeed invoked in other locations, are all examples of observing/exercising closure.</p>
<p>当然，方法可以用各种各样的方式去<em>传来传去</em>作为变量，的确可以在其他位置被触发，这都是典型的观察/使用闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar( baz );</span><br><span class="line">&#125;</span><br><span class="line">、</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	fn(); <span class="comment">// look ma, I saw closure!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We pass the inner function <code>baz</code> over to <code>bar</code>, and call that inner function (labeled <code>fn</code> now), and when we do, its closure over the inner scope of <code>foo()</code> is observed, by accessing <code>a</code>.</p>
<p>我们把内部的方法<code>baz</code>传给<code>bar</code>，然后执行这个内部方法(现在被标记成<code>fn</code>)，然后当我们这么做的时候，<code>foo()</code>内部作用域的闭包通过读取变量<code>a</code>被观察了。</p>
<p>These passings-around of functions can be indirect, too.</p>
<p>这种传递方法也可以是间接的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fn = baz; <span class="comment">// assign `baz` to global variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	fn(); <span class="comment">// look ma, I saw closure!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Whatever facility we use to <em>transport</em> an inner function outside of its lexical scope, it will maintain a scope reference to where it was originally declared, and wherever we execute it, that closure will be exercised.</p>
<p>不论我们用了什么设施来<em>运输</em>一个内部的作用域运出到他外部的作用域，这都将会保持作用域他原本声明的地方的引用，不管他在哪里被执行，这个闭包都将会被使用。</p>
<h2 id="Now-I-Can-See"><a href="#Now-I-Can-See" class="headerlink" title="Now I Can See"></a>Now I Can See</h2><h2 id="现在我看见了"><a href="#现在我看见了" class="headerlink" title="现在我看见了"></a>现在我看见了</h2><p>The previous code snippets are somewhat academic and artificially constructed to illustrate <em>using closure</em>. But I promised you something more than just a cool new toy. I promised that closure was something all around you in your existing code. Let us now <em>see</em> that truth.</p>
<p>前面的代码片段有些某种程度上有点从学术和不自然的结构上来举例说明<em>使用闭包</em>。但是我保证你看到不仅仅是一个酷的新玩具。我保证闭包在你存在的代码中到处都有。让我们现在来<em>看</em>真相。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( message );</span><br><span class="line">	&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure>
<p>We take an inner function (named <code>timer</code>) and pass it to <code>setTimeout(..)</code>. But <code>timer</code> has a scope closure over the scope of <code>wait(..)</code>, indeed keeping and using a reference to the variable <code>message</code>.</p>
<p>我们将一个内部方法(取名为<code>timer</code>)传给<code>setTimeout(..)</code>。但是<code>timer</code>有一个作用域闭包引用着作用域<code>wait(..)</code>，事实上保持和引用着变量<code>message</code>的引用。</p>
<p>A thousand milliseconds after we have executed <code>wait(..)</code>, and its inner scope should otherwise be long gone, that inner function <code>timer</code> still has closure over that scope.</p>
<p>一千毫秒之后我们执行了<code>wait(..)</code>,要不是内部的方法<code>timer</code>仍然有作用域的闭包，否则它内部的作用域应该早就消失了。</p>
<p>Deep down in the guts of the <em>Engine</em>, the built-in utility <code>setTimeout(..)</code> has reference to some parameter, probably called <code>fn</code> or <code>func</code> or something like that. <em>Engine</em> goes to invoke that function, which is invoking our inner <code>timer</code> function, and the lexical scope reference is still intact.</p>
<p>将<em>引擎</em>的核心挖的更深，构建工具<code>setTimeout(..)</code>有一些参数的引用，可能叫做<code>fn</code>或者<code>func</code>又或者是类似的名字。<em>引擎</em> 会去执行这个方法，也就是我们这里我们内部的<code>timer</code>方法，他的词法作用域引用仍然完好无损。</p>
<p><strong>Closure.</strong></p>
<p><strong>闭包。</strong></p>
<p>Or, if you’re of the jQuery persuasion (or any JS framework, for that matter):</p>
<p>或者，如果你是jQuery信仰者(或者任何一个JS框架,关于这一点)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name,selector</span>) </span>&#123;</span><br><span class="line">	$( selector ).click( <span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Activating: "</span> + name );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupBot( <span class="string">"Closure Bot 1"</span>, <span class="string">"#bot_1"</span> );</span><br><span class="line">setupBot( <span class="string">"Closure Bot 2"</span>, <span class="string">"#bot_2"</span> );</span><br></pre></td></tr></table></figure>
<p>I am not sure what kind of code you write, but I regularly write code which is responsible for controlling an entire global drone army of closure bots, so this is totally realistic!</p>
<p>我不确定你写的代码时什么类型，但是我经常写的代码来负责控制整个全球的闭包机器人军团，所以这就是现实。</p>
<p>(Some) joking aside, essentially <em>whenever</em> and <em>wherever</em> you treat functions (which access their own respective lexical scopes) as first-class values and pass them around, you are likely to see those functions exercising closure. Be that timers, event handlers, Ajax requests, cross-window messaging, web workers, or any of the other asynchronous (or synchronous!) tasks, when you pass in a <em>callback function</em>, get ready to sling some closure around!</p>
<p>将玩笑放一边，本质上你把方法(读取他们各自词法作用域)作为第一类值然后不管<em>什么时候</em>和<em>在哪里</em>将他们传来传去，我基本上可以看见这些方法运用了闭包。当你使用timers，事件处理，Ajax请求，跨window的消息，web workers，或者任何一个其他的异步(或者同步)任务，当你传入一个<em>回调方法</em>，其实就是将闭包一起甩了过去。</p>
<p><strong>Note:</strong> Chapter 3 introduced the IIFE pattern. While it is often said that IIFE (alone) is an example of observed closure, I would somewhat disagree, by our definition above.</p>
<p><strong>注意:</strong> 第三章介绍了IIFE模式。虽然经常说IIFE(独自的)是一个观察闭包的例子，但根据我们的定义，某种程度上我不同意。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>This code “works”, but it’s not strictly an observation of closure. Why? Because the function (which we named “IIFE” here) is not executed outside its lexical scope. It’s still invoked right there in the same scope as it was declared (the enclosing/global scope that also holds <code>a</code>). <code>a</code> is found via normal lexical scope look-up, not really via closure.</p>
<p>这个代码”可以工作”,但是这不是严格意义上的观察闭包。为什么？因为方法(我们在这里命名为”IIFE”)没有在他词法作用域外部执行。他仍然在他声明(包围的/全局作用域仍然保持着<code>a</code>)的同一个作用域中被执行。<code>a</code>经过普通的词法作用域查看找到，而不是真正的通过闭包找到。</p>
<p>While closure might technically be happening at declaration time, it is <em>not</em> strictly observable, and so, as they say, <em>it’s a tree falling in the forest with no one around to hear it.</em></p>
<p>虽然闭包技术上发生在声明时，但<em>不是</em>严格的可观察，所以，就像他们说的，<em>一棵树落在了森林里没人看见也没人听见。</em></p>
<p>Though an IIFE is not <em>itself</em> an example of closure, it absolutely creates scope, and it’s one of the most common tools we use to create scope which can be closed over. So IIFEs are indeed heavily related to closure, even if not exercising closure themselves.</p>
<p>尽管一个IIFE<em>本身</em>不是闭包的例子，但是他绝对创建作用域，而且他是我们用于创建作用域而且别人无法访问的最常用工具的其中之一。所以IIFE的确很大程度上和闭包相关，即使他自己没有使用闭包。</p>
<p>Put this book down right now, dear reader. I have a task for you. Go open up some of your recent JavaScript code. Look for your functions-as-values and identify where you are already using closure and maybe didn’t even know it before.</p>
<p>亲爱的读者，现在合上这本书。我有一个任务给你。去打开你最近写的JavaScript代码。找到你把方法作为参数和找出之前并不知道但使用了闭包的地方。</p>
<p>I’ll wait.</p>
<p>我会等你。</p>
<p>Now… you see!</p>
<p>现在… 你看到了！</p>
<h2 id="Loops-Closure"><a href="#Loops-Closure" class="headerlink" title="Loops + Closure"></a>Loops + Closure</h2><h2 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h2><p>The most common canonical example used to illustrate closure involves the humble for-loop.</p>
<p>一个最常见的典型的例子被使用来说明闭包的是关于最简陋的for循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Linters often complain when you put functions inside of loops, because the mistakes of not understanding closure are <strong>so common among developers</strong>. We explain how to do so properly here, leveraging the full power of closure. But that subtlety is often lost on linters and they will complain regardless, assuming you don’t <em>actually</em> know what you’re doing.</p>
<p><strong>注意：</strong> 当你把方法放在循环的里面Linters通常会警告，因为不理解闭包造成的错误<strong>在开发人员中很常见</strong>。我们会解释在这里如何做是正确的，充分利用闭包的力量。但是linters经常忽略了这里的微妙之处而且不管怎么样都要警告，就好像你<em>事实上</em>不知道你自己在做什么。</p>
<p>The spirit of this code snippet is that we would normally <em>expect</em> for the behavior to be that the numbers “1”, “2”, .. “5” would be printed out, one at a time, one per second, respectively.</p>
<p>这段代码我们通常会<em>期望</em>的举止是数字”1”, “2”, .. “5”会一个接一个一秒接一秒的各自被打印，</p>
<p>In fact, if you run this code, you get “6” printed out 5 times, at the one-second intervals.</p>
<p>事实上，如果你运行这个代码，你会得到”6”每次间隔一秒的被打印了5次。</p>
<p><strong>Huh?</strong></p>
<p><strong>啊?</strong></p>
<p>Firstly, let’s explain where <code>6</code> comes from. The terminating condition of the loop is when <code>i</code> is <em>not</em> <code>&lt;=5</code>. The first time that’s the case is when <code>i</code> is 6. So, the output is reflecting the final value of the <code>i</code> after the loop terminates.</p>
<p>首先，让我们解释<code>6</code>从哪里来。循环结束的条件是当<code>i</code><em>不</em><code>&lt;=5</code>。第一次满足这个条件是当<code>i</code>为6的时候。所以，输出是引用<code>i</code>在循环结束后最终的值。</p>
<p>This actually seems obvious on second glance. The timeout function callbacks are all running well after the completion of the loop. In fact, as timers go, even if it was <code>setTimeout(.., 0)</code> on each iteration, all those function callbacks would still run strictly after the completion of the loop, and thus print <code>6</code> each time.</p>
<p>多撇一眼的话这可能会更明显。timeout方法回调会在循环完成之后运行。事实上，作为计时器，即使每次循环为<code>setTimeout(.., 0)</code>，所有的方法回调仍然会严格的在循环完成后运行，因此每次输出<code>6</code>。</p>
<p>But there’s a deeper question at play here. What’s <em>missing</em> from our code to actually have it behave as we semantically have implied?</p>
<p>但是有一个更深的问题我们要在这里讨论，让我们的代码真正的有像我们语义上暗示的那样的举止我们<em>缺少</em>了什么？</p>
<p>What’s missing is that we are trying to <em>imply</em> that each iteration of the loop “captures” its own copy of <code>i</code>, at the time of the iteration. But, the way scope works, all 5 of those functions, though they are defined separately in each loop iteration, all <strong>are closed over the same shared global scope</strong>, which has, in fact, only one <code>i</code> in it.</p>
<p>我们缺少的是我们尝试<em>暗示</em>每次for循环捕获在每次循环的时候<code>i</code>本身的拷贝。但是，作用域是这样工作的，所有的5个方法，尽管在每次循环中定义了独立的方法，所有<strong>都被包在同一个共享全局作用域中</strong>，事实上，只有一个<code>i</code>在这个作用域中。</p>
<p>Put that way, <em>of course</em> all functions share a reference to the same <code>i</code>. Something about the loop structure tends to confuse us into thinking there’s something else more sophisticated at work. There is not. There’s no difference than if each of the 5 timeout callbacks were just declared one right after the other, with no loop at all.</p>
<p>就因为这种方式。<em>当然</em> 所有的方法分享同一个<code>i</code>引用。有些关于循环的结构会趋向于误导我们去想有些东西让他更精练的工作。不是的，5个timeout回调一个接一个的声明和有没有循环完全没有区别。</p>
<p>OK, so, back to our burning question. What’s missing? We need more <del>cowbell</del> closured scope. Specifically, we need a new closured scope for each iteration of the loop.</p>
<p>OK，所以，回到我们火烧眉毛的问题。到底少了什么？我们需要更多 <del>牛铃声</del> 闭包作用域。确切来说，我们需要给一次循环一个新的闭包作用域。</p>
<p>We learned in Chapter 3 that the IIFE creates scope by declaring a function and immediately executing it.</p>
<p>我们在第三章学到过IIFE通过声明一个方法然后立即执行他来创建作用域。</p>
<p>Let’s try:</p>
<p>让我们试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( i );</span><br><span class="line">		&#125;, i*<span class="number">1000</span> );</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Does that work? Try it. Again, I’ll wait.</p>
<p>这成功了么？再试一下。我会等着。</p>
<p>I’ll end the suspense for you. <strong>Nope.</strong> But why? We now obviously have more lexical scope. Each timeout function callback is indeed closing over its own per-iteration scope created respectively by each IIFE.</p>
<p>我会替你结束这个悬念。<strong>不行。</strong> 但是为什么?我们现在显然有了更多的词法作用域。每个timeout方法回调的确被各自自己的每一次循环执行的IIFE创建的作用域包围起来了。</p>
<p>It’s not enough to have a scope to close over <strong>if that scope is empty</strong>. Look closely. Our IIFE is just an empty do-nothing scope. It needs <em>something</em> in it to be useful to us.</p>
<p><strong>如果作用域是空的</strong> 被这样的作用域包围起来是不够的。看仔细了。我们的IIFE只一个空的什么都没做的作用域。需要<em>某些东西</em>在里面才会对我们有用。</p>
<p>It needs its own variable, with a copy of the <code>i</code> value at each iteration.</p>
<p>需要他们自己的变量，用来每次循环拷贝<code>i</code>的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> j = i;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( j );</span><br><span class="line">		&#125;, j*<span class="number">1000</span> );</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Eureka! It works!</strong></p>
<p><strong>找到了！成功了！</strong></p>
<p>A slight variation some prefer is:</p>
<p>有些人更喜欢一个稍微不一样的变形：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( j );</span><br><span class="line">		&#125;, j*<span class="number">1000</span> );</span><br><span class="line">	&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Of course, since these IIFEs are just functions, we can pass in <code>i</code>, and we can call it <code>j</code> if we prefer, or we can even call it <code>i</code> again. Either way, the code works now.</p>
<p>当然，比起IIFEs只是一个方法，我们现在传入<code>i</code>，如果我们喜欢我们可以把他叫做<code>j</code>，或者我们可以还是可以取名叫做<code>i</code>。不管哪种方法，这个代码可以成功了。</p>
<p>The use of an IIFE inside each iteration created a new scope for each iteration, which gave our timeout function callbacks the opportunity to close over a new scope for each iteration, one which had a variable with the right per-iteration value in it for us to access.</p>
<p>在每一次循环的内部使用一个IIFE替每一次循环创建一个新的作用域，给我们timeout方法回调一个机会在每一次循环闭包一个新的作用域，每一次循环都有一个变量提供一个每一次循环正确的值来读取。</p>
<p>Problem solved!</p>
<p>问题解决了！</p>
<h3 id="Block-Scoping-Revisited"><a href="#Block-Scoping-Revisited" class="headerlink" title="Block Scoping Revisited"></a>Block Scoping Revisited</h3><h3 id="重温块作用域"><a href="#重温块作用域" class="headerlink" title="重温块作用域"></a>重温块作用域</h3><p>Look carefully at our analysis of the previous solution. We used an IIFE to create new scope per-iteration. In other words, we actually <em>needed</em> a per-iteration <strong>block scope</strong>. Chapter 3 showed us the <code>let</code> declaration, which hijacks a block and declares a variable right there in the block.</p>
<p>仔细看一下我们对前面解决方案的分析。我们使用IIFE为每一次循环创建一个新的作用域。换句话来说，我们实际上<em>需要</em>一个每一个循环<strong>块级作用域</strong>。第三章像我们展示了<code>let</code>声明，它劫持了一个块然后在块里声明了一个变量。</p>
<p><strong>It essentially turns a block into a scope that we can close over.</strong> So, the following awesome code “just works”:</p>
<p><strong>这实际上将块转换成我们可以用来闭包的作用域。</strong> 所以，这个了不起的代码”就这样成功了”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">let</span> j = i; <span class="comment">// yay, block-scope for closure!</span></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( j );</span><br><span class="line">	&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>But, that’s not all!</em> (in my best Bob Barker voice). There’s a special behavior defined for <code>let</code> declarations used in the head of a for-loop. This behavior says that the variable will be declared not just once for the loop, <strong>but each iteration</strong>. And, it will, helpfully, be initialized at each subsequent iteration with the value from the end of the previous iteration.</p>
<p><em>但是，这不是全部</em> (用我最Bob Barker的声音)。<code>let</code>声明在for循环的头部使用有一个特别行为定义，这个行为说的是变量将不会仅仅为一次循环声明，<strong>而是每一次循环都声明</strong>。每一次循环按照顺序根据前一次循环完之后的值初始化值，这将会很有帮助。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How cool is that? Block scoping and closure working hand-in-hand, solving all the world’s problems. I don’t know about you, but that makes me a happy JavaScripter.</p>
<p>这有多酷？块作用域和闭包手拉着手一起工作，解决世界上所有的问题。我不认识你，但是这使我成为一个开心的JavaScript使用者。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>There are other code patterns which leverage the power of closure but which do not on the surface appear to be about callbacks. Let’s examine the most powerful of them: <em>the module</em>.</p>
<p>有其他一种代码的模式充分利用闭包的力量但是不像回调一样在表面显示。让我们调查一下最强大的他们：<em>模块</em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( something );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As this code stands right now, there’s no observable closure going on. We simply have some private data variables <code>something</code> and <code>another</code>, and a couple of inner functions <code>doSomething()</code> and <code>doAnother()</code>, which both have lexical scope (and thus closure!) over the inner scope of <code>foo()</code>.</p>
<p>就像这个代码标准一样，他们没有可观察的闭包在执行。我们简单有一些私有的数据变量<code>something</code> 和 <code>another</code>，还有一对内部方法<code>doSomething()</code> 和 <code>doAnother()</code>，他们都有词法作用域(这样闭包！)在<code>foo()</code>内部作用域中。</p>
<p>But now consider:</p>
<p>但是现在考虑一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( something );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		doSomething: doSomething,</span><br><span class="line">		doAnother: doAnother</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>This is the pattern in JavaScript we call <em>module</em>. The most common way of implementing the module pattern is often called “Revealing Module”, and it’s the variation we present here.</p>
<p>这个模式在JavaScript中我们叫做<em>模块</em>。</p>
<p>Let’s examine some things about this code.</p>
<p>让我们来调查关于这个代码的一些事情。</p>
<p>Firstly, <code>CoolModule()</code> is just a function, but it <em>has to be invoked</em> for there to be a module instance created. Without the execution of the outer function, the creation of the inner scope and the closures would not occur.</p>
<p>首先，<code>CoolModule()</code>只是一个方法，但是<em>随着他</em>的执行他创建了一个模块实例创建了。如果不执行外部的方法，创建的内部作用域和闭包将不会被执行。</p>
<p>Secondly, the <code>CoolModule()</code> function returns an object, denoted by the object-literal syntax <code>{ key: value, ... }</code>. The object we return has references on it to our inner functions, but <em>not</em> to our inner data variables. We keep those hidden and private. It’s appropriate to think of this object return value as essentially a <strong>public API for our module</strong>.</p>
<p>其次，<code>CoolModule()</code>方法返回一个对象，通过对象字面语法<code>{ key: value, ... }</code>被标记。我们返回的对象有我们内部方法的引用，但是<em>没有</em>我们的内部数据变量。我们保持他们的隐藏和私有。对我们返回的对象合适的理解是本质上他们是一个<strong>我们模块的公开API</strong>。</p>
<p>This object return value is ultimately assigned to the outer variable <code>foo</code>, and then we can access those property methods on the API, like <code>foo.doSomething()</code>.</p>
<p>返回的对象最终赋值给外部的变量<code>foo</code>，接下来我们可以读取他的API属性方法，像<code>foo.doSomething()</code>。</p>
<p><strong>Note:</strong> It is not required that we return an actual object (literal) from our module. We could just return back an inner function directly. jQuery is actually a good example of this. The <code>jQuery</code> and <code>$</code> identifiers are the public API for the jQuery “module”, but they are, themselves, just a function (which can itself have properties, since all functions are objects).</p>
<p><strong>注意：</strong> 从我们模块里返回一个对象(字面上)这不是必须的。我们可以直接返回一个内部方法。jQuery事实上就是一个关于这个很好的例子。<code>jQuery</code> 和 <code>$</code> 标识符是jQuery”模块”的的公开API,但是他自己只是一个方法(他可以有自己的属性，因为所有的方法就是对象)。</p>
<p>The <code>doSomething()</code> and <code>doAnother()</code> functions have closure over the inner scope of the module “instance” (arrived at by actually invoking <code>CoolModule()</code>). When we transport those functions outside of the lexical scope, by way of property references on the object we return, we have now set up a condition by which closure can be observed and exercised.</p>
<p><code>doSomething()</code> 和 <code>doAnother()</code>方法模块”实例”内部作用域的闭包(真正运行<code>CoolModule()</code>时到来)。当我们将这些方法通过引用我们返回的对象属性的方式搬移出词法作用域的外面，我们现在就设置好了闭包可以被观察和使用的条件。</p>
<p>To state it more simply, there are two “requirements” for the module pattern to be exercised:</p>
<p>更简单的说，模块模式被使用有两个”必要条件”</p>
<ol>
<li><p>There must be an outer enclosing function, and it must be invoked at least once (each time creates a new module instance).</p>
</li>
<li><p>必须有一个外部包围的方法，至少需要被执行一次(每次创建一个新的模块实例)。</p>
</li>
<li><p>The enclosing function must return back at least one inner function, so that this inner function has closure over the private scope, and can access and/or modify that private state.</p>
</li>
<li><p>包围的方法需要返回至少一个内部方法，使这个内部方法有私有作用域的闭包，这样他可以访问和/或修改那个私有状态。</p>
</li>
</ol>
<p>An object with a function property on it alone is not <em>really</em> a module. An object which is returned from a function invocation which only has data properties on it and no closured functions is not <em>really</em> a module, in the observable sense.</p>
<p>一个对象仅仅有一个方法属性不是<em>真正</em>的一个模块。一个对象通过方法执行返回而这个方法只有数据属性没有闭包方法这不是<em>真正</em>的一个模块，从可观察的角度来说。</p>
<p>The code snippet above shows a standalone module creator called <code>CoolModule()</code> which can be invoked any number of times, each time creating a new module instance. A slight variation on this pattern is when you only care to have one instance, a “singleton” of sorts:</p>
<p>代码片段关于一个独立的模块创建者叫做<code>CoolModule()</code>它可以被执行任意次数，每次执行创建一个新的模块实例。这个模式的一个轻微的变化是当你只想有一个实例，类似一个”单例”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( something );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		doSomething: doSomething,</span><br><span class="line">		doAnother: doAnother</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>Here, we turned our module function into an IIFE (see Chapter 3), and we <em>immediately</em> invoked it and assigned its return value directly to our single module instance identifier <code>foo</code>.</p>
<p>这里，我们将我们的模块方法转移到一个IIFE钟(见第三章)，然后我们<em>立刻</em>执行他然后将返回的值直接赋值给我们的单独的模块实例标识符<code>foo</code>。</p>
<p>Modules are just functions, so they can receive parameters:</p>
<p>模块就是方法，所以它可以接受参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( id );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		identify: identify</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = CoolModule( <span class="string">"foo 1"</span> );</span><br><span class="line"><span class="keyword">var</span> foo2 = CoolModule( <span class="string">"foo 2"</span> );</span><br><span class="line"></span><br><span class="line">foo1.identify(); <span class="comment">// "foo 1"</span></span><br><span class="line">foo2.identify(); <span class="comment">// "foo 2"</span></span><br></pre></td></tr></table></figure>
<p>Another slight but powerful variation on the module pattern is to name the object you are returning as your public API:</p>
<p>另外一个对于模块模式的轻微但是很强大的变化是将你返回的对象取名作为你的公开API:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// modifying the public API</span></span><br><span class="line">		publicAPI.identify = identify2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">identify1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( id );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">identify2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( id.toUpperCase() );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">		change: change,</span><br><span class="line">		identify: identify1</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)( <span class="string">"foo module"</span> );</span><br><span class="line"></span><br><span class="line">foo.identify(); <span class="comment">// foo module</span></span><br><span class="line">foo.change();</span><br><span class="line">foo.identify(); <span class="comment">// FOO MODULE</span></span><br></pre></td></tr></table></figure>
<p>By retaining an inner reference to the public API object inside your module instance, you can modify that module instance <strong>from the inside</strong>, including adding and removing methods, properties, <em>and</em> changing their values.</p>
<p>通过保持一个在你模块实例内部的公开API对象的内部引用，你可以<strong>从内部</strong>修改模块实例，包括增加和删除方法，属性，<em>和</em> 修改他们的值。</p>
<h3 id="Modern-Modules"><a href="#Modern-Modules" class="headerlink" title="Modern Modules"></a>Modern Modules</h3><h3 id="现代模块"><a href="#现代模块" class="headerlink" title="现代模块"></a>现代模块</h3><p>Various module dependency loaders/managers essentially wrap up this pattern of module definition into a friendly API. Rather than examine any one particular library, let me present a <em>very simple</em> proof of concept <strong>for illustration purposes (only)</strong>:</p>
<p>各种模块依赖的加载机制/管理机制本质上是包裹这个模块模式来定义一个友好的API。与其检验任何一个特别的库，<strong>为了举例说明的目的(仅仅)</strong> 让我来提出一个<em>非常简单</em>证明观点 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">			deps[i] = modules[deps[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		modules[name] = impl.apply( impl, deps );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> modules[name];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		define: define,</span><br><span class="line">		<span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>The key part of this code is <code>modules[name] = impl.apply(impl, deps)</code>. This is invoking the definition wrapper function for a module (passing in any dependencies), and storing the return value, the module’s API, into an internal list of modules tracked by name.</p>
<p>这个代码的关键部分是<code>modules[name] = impl.apply(impl, deps)</code>。执行方法来替一个模块定义一个包围的方法(传入任何的依赖)，然后存储返回值，也就是模块的API，存储在一个模块内部的列表里用名字跟踪。</p>
<p>And here’s how I might use it to define some modules:</p>
<p>这里是我如何使用来定一些模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MyModules.define( <span class="string">"bar"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		hello: hello</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">MyModules.define( <span class="string">"foo"</span>, [<span class="string">"bar"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		awesome: awesome</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = MyModules.get( <span class="string">"bar"</span> );</span><br><span class="line"><span class="keyword">var</span> foo = MyModules.get( <span class="string">"foo"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello( <span class="string">"hippo"</span> )</span><br><span class="line">); <span class="comment">// Let me introduce: hippo</span></span><br><span class="line"></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<p>Both the “foo” and “bar” modules are defined with a function that returns a public API. “foo” even receives the instance of “bar” as a dependency parameter, and can use it accordingly.</p>
<p>“foo” 和 “bar”模块都通过一个方法来定义然后返回一个公开的API。 “foo”甚至可以接受”bar”的实例作为一个依赖参数，而且还可以相应的使用。</p>
<p>Spend some time examining these code snippets to fully understand the power of closures put to use for our own good purposes. The key take-away is that there’s not really any particular “magic” to module managers. They fulfill both characteristics of the module pattern I listed above: invoking a function definition wrapper, and keeping its return value as the API for that module.</p>
<p>花费一些时间来测验这些代码片段来完全理解闭包的力量来为我们的好的目标使用。关键之处在于模块管理并不是任何特别的”魔法”。他实现了我列下来的关于模块模式的全部特性:执行一个方法定义包围者，然后保持他的返回值作为模块的API。</p>
<p>In other words, modules are just modules, even if you put a friendly wrapper tool on top of them.</p>
<p>换句话来说，模块只是模块，尽管你给他套上了友好的外衣。</p>
<h3 id="Future-Modules"><a href="#Future-Modules" class="headerlink" title="Future Modules"></a>Future Modules</h3><h3 id="未来模块"><a href="#未来模块" class="headerlink" title="未来模块"></a>未来模块</h3><p>ES6 adds first-class syntax support for the concept of modules. When loaded via the module system, ES6 treats a file as a separate module. Each module can both import other modules or specific API members, as well export their own public API members.</p>
<p>ES6加入了第一类型的语法来支持模块这个观念。当加载模块经由模块系统,ES6对待一个文件作为一个独立的模块。每个模块都可以引入其他模块或者具体的API对象，也可以输出自己的公开API对象。</p>
<p><strong>Note:</strong> Function-based modules aren’t a statically recognized pattern (something the compiler knows about), so their API semantics aren’t considered until run-time. That is, you can actually modify a module’s API during the run-time (see earlier <code>publicAPI</code> discussion).</p>
<p><strong>注意:</strong> 方法为基础的模块不是一个静态被识别的模式(一些编译器知道的)，所以他们API语义不被考虑直到运行时。就因为这个，你可以在运行时修改一个模块的API(见更简单的<code>publicAPI</code>讨论)。</p>
<p>By contrast, ES6 Module APIs are static (the APIs don’t change at run-time). Since the compiler knows <em>that</em>, it can (and does!) check during (file loading and) compilation that a reference to a member of an imported module’s API <em>actually exists</em>. If the API reference doesn’t exist, the compiler throws an “early” error at compile-time, rather than waiting for traditional dynamic run-time resolution (and errors, if any).</p>
<p>相反的，ES6模块API是静态的(API不会再运行时被修改)。因为编译器知道<em>那个</em>,他可以(和做)在(文件加载和)编译时检查一个被导入模块的引用对象API<em>是否存在</em>。如果API引用不存在，编译器会在编译时抛出一个”过早(early)”错误，而不是等到传统动态运行时解决方案(和错误,如果有的话)。</p>
<p>ES6 modules <strong>do not</strong> have an “inline” format, they must be defined in separate files (one per module). The browsers/engines have a default “module loader” (which is overridable, but that’s well-beyond our discussion here) which synchronously loads a module file when it’s imported.</p>
<p>ES6模块<strong>不会</strong>有一个”行内”格式化,他们必须在一个独立的文件中定义(每个一个模块)。浏览器/引擎有一个默认的”模块加载器”(可以被覆盖的，但是这个已经超出我们的在这里的讨论)他会在导入的时候同步在家一个模块。</p>
<p>Consider:</p>
<p>考虑：</p>
<p><strong>bar.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> hello;</span><br></pre></td></tr></table></figure></p>
<p><strong>foo.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import only `hello()` from the "bar" module</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(</span><br><span class="line">		hello( hungry ).toUpperCase()</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> awesome;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import the entire "foo" and "bar" modules</span></span><br><span class="line"><span class="built_in">module</span> foo <span class="keyword">from</span> <span class="string">"foo"</span>;</span><br><span class="line"><span class="built_in">module</span> bar <span class="keyword">from</span> <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello( <span class="string">"rhino"</span> )</span><br><span class="line">); <span class="comment">// Let me introduce: rhino</span></span><br><span class="line"></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Separate files <strong>“foo.js”</strong> and <strong>“bar.js”</strong> would need to be created, with the contents as shown in the first two snippets, respectively. Then, your program would load/import those modules to use them, as shown in the third snippet.</p>
<p><strong>注意:</strong> <strong>“foo.js”</strong> 和 <strong>“bar.js”</strong> 这两个单独的文件需要各自被创建，他们的内容就是第一第二个片段。接下来，你的程序会加载/引入这些模块然后使用他们，就像第三段代码这样。</p>
<p><code>import</code> imports one or more members from a module’s API into the current scope, each to a bound variable (<code>hello</code> in our case). <code>module</code> imports an entire module API to a bound variable (<code>foo</code>, <code>bar</code> in our case). <code>export</code> exports an identifier (variable, function) to the public API for the current module. These operators can be used as many times in a module’s definition as is necessary.</p>
<p><code>import</code>从一个模块的API中导入一个或者多个对象到当前的作用域，每一个绑定一个变量(在我们的例子中是<code>hello</code>)。<code>module</code>导入一整个模块的API然后绑定一个变量(在我们例子中是<code>foo</code>, <code>bar</code>)。<code>export</code>输出一个标识符(变量,方法)作为当前模块的公开API。这些操作可以在必要的时候在一个模块的定义中使用多次。</p>
<p>The contents inside the <em>module file</em> are treated as if enclosed in a scope closure, just like with the function-closure modules seen earlier.</p>
<p><em>模块文件</em> 内部的内容被当做包围的一个闭包作用域，就好像我们之前看到的方法闭包模块。</p>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><h2 id="回顾-TL-DR"><a href="#回顾-TL-DR" class="headerlink" title="回顾 (TL;DR)"></a>回顾 (TL;DR)</h2><p>Closure seems to the un-enlightened like a mystical world set apart inside of JavaScript which only the few bravest souls can reach. But it’s actually just a standard and almost obvious fact of how we write code in a lexically scoped environment, where functions are values and can be passed around at will.</p>
<p>闭包似乎未被启发就像JavaScript中的一个神秘的世界只有一小部分最勇敢的灵魂可以达到。但是事实上是我们如何在一个词法作用域的环境中写代码的一个标准和几乎显而易见的事实，方法就是值可以根据你的需要被传来传去。</p>
<p><strong>Closure is when a function can remember and access its lexical scope even when it’s invoked outside its lexical scope.</strong></p>
<p><strong>闭包就是当一个方法可以记住和读取自己的词法作用域即使当他在他的词法作用域外部被执行。</strong></p>
<p>Closures can trip us up, for instance with loops, if we’re not careful to recognize them and how they work. But they are also an immensely powerful tool, enabling patterns like <em>modules</em> in their various forms.</p>
<p>如果我们不小心的识别闭包和不知道他们如何工作，在循环中使用实例，闭包可以将我们绊倒。但是他们也是一个有巨大力量的工具，启发了各种模式 <em>模块</em> 就是他的变化形式。</p>
<p>Modules require two key characteristics: 1) an outer wrapping function being invoked, to create the enclosing scope 2) the return value of the wrapping function must include reference to at least one inner function that then has closure over the private inner scope of the wrapper.</p>
<p>模块需要两个关键的特性：1)一个外部包围的方法需要被执行，来创建一个包围的作用域 2) 包围方法返回的值必须包含至少一个内部方法的引用,这个内部方法有包围函数的私有内部作用域的闭包。</p>
<p>Now we can see closures all around our existing code, and we have the ability to recognize and leverage them to our own benefit!</p>
<p>现在我们可以看到闭包在我们已经存在代码中到处都是，我们有能力去识别可以利用他们来为我们创造利益。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-5-Scope-Closure/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-You-Don-t-Know-JS-Scope-Closures-Chapter-4-Hoisting" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-4-Hoisting/">You Don&#39;t Know JS: Scope &amp; Closures-Chapter 4: Hoisting</a>
    </h1>
  

        
        <a href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-4-Hoisting/" class="archive-article-date">
  	<time datetime="2017-07-29T04:16:43.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="You-Don’t-Know-JS-Scope-amp-Closures"><a href="#You-Don’t-Know-JS-Scope-amp-Closures" class="headerlink" title="You Don’t Know JS: Scope &amp; Closures"></a>You Don’t Know JS: Scope &amp; Closures</h1><h1 id="Chapter-4-Hoisting"><a href="#Chapter-4-Hoisting" class="headerlink" title="Chapter 4: Hoisting"></a>Chapter 4: Hoisting</h1><h1 id="你不知道的JS：作用域和闭包"><a href="#你不知道的JS：作用域和闭包" class="headerlink" title="你不知道的JS：作用域和闭包"></a>你不知道的JS：作用域和闭包</h1><h1 id="第四章：提升"><a href="#第四章：提升" class="headerlink" title="第四章：提升"></a>第四章：提升</h1><p>By now, you should be fairly comfortable with the idea of scope, and how variables are attached to different levels of scope depending on where and how they are declared. Both function scope and block scope behave by the same rules in this regard: any variable declared within a scope is attached to that scope.</p>
<p>现在,你应该对作用域的概念有了相当的熟悉，变量如何依附于不同层级的作用域取决于他们在哪里和如何声明。方法作用域和块作用都有相同的规则：任何变量在某个作用域中声明他就依附于这个作用域。</p>
<p>But there’s a subtle detail of how scope attachment works with declarations that appear in various locations within a scope, and that detail is what we will examine here.</p>
<p>但是有一个微妙的细节就是作用域和似乎在作用域内部各种位置变量是如何工作的，这个细节是我们将会在这里调查的。</p>
<h2 id="Chicken-Or-The-Egg"><a href="#Chicken-Or-The-Egg" class="headerlink" title="Chicken Or The Egg?"></a>Chicken Or The Egg?</h2><h2 id="鸡或者是蛋"><a href="#鸡或者是蛋" class="headerlink" title="鸡或者是蛋"></a>鸡或者是蛋</h2><p>There’s a temptation to think that all of the code you see in a JavaScript program is interpreted line-by-line, top-down in order, as the program executes. While that is substantially true, there’s one part of that assumption which can lead to incorrect thinking about your program.</p>
<p>自上往下的顺序,在程序执行的时候，会诱使你觉得你看到的JavaScript程序是一行接一行被解释的。虽然这大体上是正确的，但是这个猜测的一部分会使你不准确的想你的程序。</p>
<p>Consider this code:</p>
<p>考虑这个代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>What do you expect to be printed in the <code>console.log(..)</code> statement?</p>
<p><code>console.log(..)</code>表达式会输出什么你是如何猜测的?</p>
<p>Many developers would expect <code>undefined</code>, since the <code>var a</code> statement comes after the <code>a = 2</code>, and it would seem natural to assume that the variable is re-defined, and thus assigned the default <code>undefined</code>. However, the output will be <code>2</code>.</p>
<p>很多开发者会猜测<code>undefined</code>,因为<code>var a</code>表达式在<code>a = 2</code>之后,这很自然的会假设变量被重复定义了，这样被赋值默认值<code>undefined</code>。然而,输出将会是<code>2</code>。</p>
<p>Consider another piece of code:</p>
<p>考虑一下另外一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>You might be tempted to assume that, since the previous snippet exhibited some less-than-top-down looking behavior, perhaps in this snippet, <code>2</code> will also be printed. Others may think that since the <code>a</code> variable is used before it is declared, this must result in a <code>ReferenceError</code> being thrown.</p>
<p>因为前面一段代码展示的绝不是自上到下的的举止，你也许会被诱惑去假设，也许在这段片段中，仍然将输出<code>2</code>。其他可能会像因为  <code>a</code>在声明之前被使用，结果肯定会抛出一个<code>ReferenceError</code>(引用错误)的错误。</p>
<p>Unfortunately, both guesses are incorrect. <code>undefined</code> is the output.</p>
<p>不幸的是，他们的猜测都是不正确的。 <code>undefined</code> 才是输出。</p>
<p><strong>So, what’s going on here?</strong> It would appear we have a chicken-and-the-egg question. Which comes first, the declaration (“egg”), or the assignment (“chicken”)?</p>
<p><strong>所以，这里发生了什么？</strong> 这似乎看起来让我们有了一个先有鸡还是先有蛋的问题。什么在前，是声明(“蛋”)，或者是赋值(“鸡”)。</p>
<h2 id="The-Compiler-Strikes-Again"><a href="#The-Compiler-Strikes-Again" class="headerlink" title="The Compiler Strikes Again"></a>The Compiler Strikes Again</h2><h2 id="编译者再次来袭"><a href="#编译者再次来袭" class="headerlink" title="编译者再次来袭"></a>编译者再次来袭</h2><p>To answer this question, we need to refer back to Chapter 1, and our discussion of compilers. Recall that the <em>Engine</em> actually will compile your JavaScript code before it interprets it. Part of the compilation phase was to find and associate all declarations with their appropriate scopes. Chapter 2 showed us that this is the heart of Lexical Scope.</p>
<p>为了回答这个问题，我们需要参考之前的第一章，我们讨论过的编译器。回顾之前<em>引擎</em>实际上会在解释之前编译你的JavaScript代码。编译阶段的有一部分就是找到所有变量然后将他们和所占用的作用域联系起来。第二章向我们展示了这是词法作用域的核心。</p>
<p>So, the best way to think about things is that all declarations, both variables and functions, are processed first, before any part of your code is executed.</p>
<p>所以，对于所有变量，不论是变量还是方法，最好把他们想成，他们会你的代码被执行之前的任何一步先被处理。</p>
<p>When you see <code>var a = 2;</code>, you probably think of that as one statement. But JavaScript actually thinks of it as two statements: <code>var a;</code> and <code>a = 2;</code>. The first statement, the declaration, is processed during the compilation phase. The second statement, the assignment, is left <strong>in place</strong> for the execution phase.</p>
<p>当你看见 <code>var a = 2;</code>,你可能把他认为是一个表达式。但是JavaScript实际上把他认为是两个表达式:<code>var a;</code>和<code>a = 2;</code>。第一个表达式，是一个声明，在编译阶段被处理。第二个表达式，是赋值表达式，在他的位置上在执行阶段执行。</p>
<p>Our first snippet then should be thought of as being handled like this:</p>
<p>我们的第一个片段我们可以把他想象成会像接下来这样处理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>…where the first part is the compilation and the second part is the execution.</p>
<p>哪里第一部分是编译第二部分是执行。</p>
<p>Similarly, our second snippet is actually processed as:</p>
<p>类似的，我们的第二段代码实际上会这样处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>So, one way of thinking, sort of metaphorically, about this process, is that variable and function declarations are “moved” from where they appear in the flow of the code to the top of the code. This gives rise to the name “Hoisting”.</p>
<p>所以，关于这个过程，可以把他想象成，类似比喻的方式，变量和方法声明会从在某些代码流中出现”被移动”到代码的顶部。这就有了名字”提升”。</p>
<p>In other words, <strong>the egg (declaration) comes before the chicken (assignment)</strong>.</p>
<p>换句话来说，<strong>先有蛋(声明)然后有鸡(赋值)</strong>。</p>
<p><strong>Note:</strong> Only the declarations themselves are hoisted, while any assignments or other executable logic are left <em>in place</em>. If hoisting were to re-arrange the executable logic of our code, that could wreak havoc.</p>
<p><strong>注意：</strong> 只有声明自己会被提升，任何赋值或者其他可执行的逻辑都会留在原地。如果提升会重新安排我们代码的可执行逻辑，那会造成大灾难。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>foo</code>‘s declaration (which in this case <em>includes</em> the implied value of it as an actual function) is hoisted, such that the call on the first line is able to execute.</p>
<p>方法<code>foo</code>的声明(在这个例子中<em>包含</em>了一个隐含的值实际作为一个方法)被提升了，所以在第一行的调用时可以执行的。</p>
<p>It’s also important to note that hoisting is <strong>per-scope</strong>. So while our previous snippets were simplified in that they only included global scope, the <code>foo(..)</code> function we are now examining itself exhibits that <code>var a</code> is hoisted to the top of <code>foo(..)</code> (not, obviously, to the top of the program). So the program can perhaps be more accurately interpreted like this:</p>
<p>注意到提升是<strong>依照作用域</strong>来的是很重要的。虽然我们的前一段代码被简化成只包含全局作用域，我们需要测试的方法<code>foo(..)</code>自己展示了，变量<code>var a</code>被提升到<code>foo(..)</code>的顶端(显然，不是程序的顶部)。所以程序也许可以更准确的像这样解释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>Function declarations are hoisted, as we just saw. But function expressions are not.</p>
<p>就像我们之前看到的，方法声明会被提升。但是方法表达式不会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// not ReferenceError, but TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The variable identifier <code>foo</code> is hoisted and attached to the enclosing scope (global) of this program, so <code>foo()</code> doesn’t fail as a <code>ReferenceError</code>. But <code>foo</code> has no value yet (as it would if it had been a true function declaration instead of expression). So, <code>foo()</code> is attempting to invoke the <code>undefined</code> value, which is a <code>TypeError</code> illegal operation.</p>
<p>变量标识符<code>foo</code>被提升了然后依附于程序中包围的作用域(全局)，所以<code>foo()</code>的结果不是失败然后抛出一个<code>ReferenceError(引用错误)</code>错误。但是<code>foo</code>还没有值(如果他是一个方法声明而不是一个方法表达式那么他就会有值)。所以，<code>foo()</code>企图触发一个<code>undefined</code>值，这是一个<code>TypeError(类型错误)</code>的不合法操作。</p>
<p>Also recall that even though it’s a named function expression, the name identifier is not available in the enclosing scope:</p>
<p>即使方法表达式被取了名字，这个标识符的名字在包围的作用域中也不是变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This snippet is more accurately interpreted (with hoisting) as:</p>
<p>这个片段可以更精确的被解释(提升)为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> bar = ...self...</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions-First"><a href="#Functions-First" class="headerlink" title="Functions First"></a>Functions First</h2><h2 id="方法优先"><a href="#方法优先" class="headerlink" title="方法优先"></a>方法优先</h2><p>Both function declarations and variable declarations are hoisted. But a subtle detail (that <em>can</em> show up in code with multiple “duplicate” declarations) is that functions are hoisted first, and then variables.</p>
<p>方法声明和变量声明都会提升。但是有个微妙的细节(<em>可以</em> 在代码中通过声明多个重复变量来显示)是方法会先被提升，然后是变量。</p>
<p>Consider:</p>
<p>考虑一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>1</code> is printed instead of <code>2</code>! This snippet is interpreted by the <em>Engine</em> as:</p>
<p><code>1</code> 会被输出而不是 <code>2</code>！这个片段被引擎解释为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Notice that <code>var foo</code> was the duplicate (and thus ignored) declaration, even though it came before the <code>function foo()...</code> declaration, because function declarations are hoisted before normal variables.</p>
<p>注意<code>var foo</code>是一个重复(因此被忽略)声明，尽管他在<code>function foo()...</code>之后声明，因为方法声明会被提升到普通声明之后。</p>
<p>While multiple/duplicate <code>var</code> declarations are effectively ignored, subsequent function declarations <em>do</em> override previous ones.</p>
<p>虽然多个/重复 <code>var</code> 声明会被忽略，但是按照顺序方法声明覆盖了前面一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While this all may sound like nothing more than interesting academic trivia, it highlights the fact that duplicate definitions in the same scope are a really bad idea and will often lead to confusing results.</p>
<p>虽然这一切似乎听起来只不过是有趣的学术上的琐事，但是要强调的事实是在同个作用域中重复定义真的是个不好的主意而且将会引起令人疑惑的结果。</p>
<p>Function declarations that appear inside of normal blocks typically hoist to the enclosing scope, rather than being conditional as this code implies:</p>
<p>方法声明在普通的块中出现通常会提升到包围他的作用域中，而不是像这段代码暗示的传统方式一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// "b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"a"</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"b"</span> ); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, it’s important to note that this behavior is not reliable and is subject to change in future versions of JavaScript, so it’s probably best to avoid declaring functions in blocks.</p>
<p>然而，注意到这个举止是不可信任的而且根据未来的JavaScript版本修改会受影响是很重要的，所以最好尽可能避免在块中声明方法。</p>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><h2 id="回顾-TL-DR"><a href="#回顾-TL-DR" class="headerlink" title="回顾(TL;DR)"></a>回顾(TL;DR)</h2><p>We can be tempted to look at <code>var a = 2;</code> as one statement, but the JavaScript <em>Engine</em> does not see it that way. It sees <code>var a</code> and <code>a = 2</code> as two separate statements, the first one a compiler-phase task, and the second one an execution-phase task.</p>
<p>我们会被诱惑把<code>var a = 2;</code>当成一个表达式，但是JavaScript <em>引擎</em> 不会把他认为这个样子。他把<code>var a</code>和<code>a = 2</code>作为两个完全分开的表达式，第一个是编译阶段的任务，而第二个是执行阶段的任务。</p>
<p>What this leads to is that all declarations in a scope, regardless of where they appear, are processed <em>first</em> before the code itself is executed. You can visualize this as declarations (variables and functions) being “moved” to the top of their respective scopes, which we call “hoisting”.</p>
<p>作用域中的所有声明会如何被处理，不管在哪里出现，会在代码自己执行之前<em>首先</em>被处理。你可以把这个视作变量(变量和方法)会<em>被移动</em>到各自的作用域的顶上，我们叫做”提升”。</p>
<p>Declarations themselves are hoisted, but assignments, even assignments of function expressions, are <em>not</em> hoisted.</p>
<p>变量他自己会被提升，但是赋值，即使是方法表达式的赋值，都<em>不会</em>被提升</p>
<p>Be careful about duplicate declarations, especially mixed between normal var declarations and function declarations – peril awaits if you do!</p>
<p>小心重复的声明，特别是普通的var声明和方法声明混合的情况 – 如果你这么做的话会面临严重的危险！</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-4-Hoisting/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-You-Don-t-Know-JS-Scope-Closures-Chapter-3-Function-vs-Block-Scope" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-3-Function-vs-Block-Scope/">You Don&#39;t Know JS: Scope &amp; Closures-Chapter 3: Function vs. Block Scope</a>
    </h1>
  

        
        <a href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-3-Function-vs-Block-Scope/" class="archive-article-date">
  	<time datetime="2017-07-29T04:16:13.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="You-Don’t-Know-JS-Scope-amp-Closures"><a href="#You-Don’t-Know-JS-Scope-amp-Closures" class="headerlink" title="You Don’t Know JS: Scope &amp; Closures"></a>You Don’t Know JS: Scope &amp; Closures</h1><h1 id="Chapter-3-Function-vs-Block-Scope"><a href="#Chapter-3-Function-vs-Block-Scope" class="headerlink" title="Chapter 3: Function vs. Block Scope"></a>Chapter 3: Function vs. Block Scope</h1><h1 id="你不知道的JS-作用域和闭包"><a href="#你不知道的JS-作用域和闭包" class="headerlink" title="你不知道的JS:作用域和闭包"></a>你不知道的JS:作用域和闭包</h1><h1 id="第三章-方法-vs-作用域块"><a href="#第三章-方法-vs-作用域块" class="headerlink" title="第三章:方法 vs. 作用域块"></a>第三章:方法 vs. 作用域块</h1><p>As we explored in Chapter 2, scope consists of a series of “bubbles” that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author-time.</p>
<p>根据我们在第二章探讨的，作用域由一系列的”气泡”组成每个充当容器或者桶，内部有识别符(变量,方法)被声明。这些气泡有序的嵌套着其他气泡，这些嵌套关系在书写时间被定义。</p>
<p>But what exactly makes a new bubble? Is it only the function? Can other structures in JavaScript create bubbles of scope?</p>
<p>但是到底是什么创造了新的气泡？只是方法？是否有其他构造在JavaScript里可以创造作用域气泡？</p>
<h2 id="Scope-From-Functions"><a href="#Scope-From-Functions" class="headerlink" title="Scope From Functions"></a>Scope From Functions</h2><h2 id="方法作用域"><a href="#方法作用域" class="headerlink" title="方法作用域"></a>方法作用域</h2><p>The most common answer to those questions is that JavaScript has function-based scope. That is, each function you declare creates a bubble for itself, but no other structures create their own scope bubbles. As we’ll see in just a little bit, this is not quite true.</p>
<p>对于这些问题最常见的回答是JavaScript是基于方法的作用域。就因为这样，每个你声明的方法就为他自己创建一个气泡，但是没有其他结构可以创建他们自己的作用域气泡。但是我们将马上会看到,这不是完全正确的。</p>
<p>But first, let’s explore function scope and its implications.</p>
<p>但是首先,我们探索方法作用域和他的含义。</p>
<p>Consider this code:</p>
<p>考虑这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// more code</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this snippet, the scope bubble for <code>foo(..)</code> includes identifiers <code>a</code>, <code>b</code>, <code>c</code> and <code>bar</code>. <strong>It doesn’t matter</strong> <em>where</em> in the scope a declaration appears, the variable or function belongs to the containing scope bubble, regardless. We’ll explore how exactly <em>that</em> works in the next chapter.</p>
<p>在这个片段中,<code>foo(..)</code>气泡作用域包含了标识符<code>a</code>, <code>b</code>, <code>c</code> 和 <code>bar</code>。不管作用域在 <em>哪里</em> 出现声明<strong>这都没关系</strong>,变量或者方法属于包含他的作用域气泡。我们会在下一章探索 <em>那</em> 到底是如何工作的。</p>
<p><code>bar(..)</code> has its own scope bubble. So does the global scope, which has just one identifier attached to it: <code>foo</code>.</p>
<p><code>bar(..)</code>有他自己的作用域气泡。全局作用域也是如此,他只有一个标识符属于他：<code>foo</code>。</p>
<p>Because <code>a</code>, <code>b</code>, <code>c</code>, and <code>bar</code> all belong to the scope bubble of <code>foo(..)</code>, they are not accessible outside of <code>foo(..)</code>. That is, the following code would all result in <code>ReferenceError</code> errors, as the identifiers are not available to the global scope:</p>
<p>因为<code>a</code>, <code>b</code>, <code>c</code>和<code>bar</code>都属于作用域<code>foo(..)</code>，<code>foo(..)</code>外部是无法访问的。所以接下来的代码会都会抛出<code>ReferenceError(引用错误)</code>错误，因为标识符对于全局作用域是不可获得的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar(); <span class="comment">// fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a, b, c ); <span class="comment">// all 3 fail</span></span><br></pre></td></tr></table></figure>
<p>However, all these identifiers (<code>a</code>, <code>b</code>, <code>c</code>, <code>foo</code>, and <code>bar</code>) are accessible <em>inside</em> of <code>foo(..)</code>, and indeed also available inside of <code>bar(..)</code> (assuming there are no shadow identifier declarations inside <code>bar(..)</code>).</p>
<p>然而，所有的标识符(<code>a</code>, <code>b</code>, <code>c</code>, <code>foo</code>, 和 <code>bar</code>)在<code>foo(..)</code>里都是可以访问的，在<code>bar(..)</code>内部实际上也可以访问(假设在<code>bar(..)</code>内部没有遮蔽的识别符声明)。</p>
<p>Function scope encourages the idea that all variables belong to the function, and can be used and reused throughout the entirety of the function (and indeed, accessible even to nested scopes). This design approach can be quite useful, and certainly can make full use of the “dynamic” nature of JavaScript variables to take on values of different types as needed.</p>
<p>方法作用域鼓励的想法是(encourages:to persuade sb to do sth by making it easier for them and making them believe it is a good thing to do)所有的变量属于方法，变量可以贯穿整个方法使用和重用(事实上,在被嵌套的方法中也可以访问)。整个设计将会变得十分有用，肯定可以充分利用”动态”原始JavaScript变量来根据不同的需要的类型获取值。</p>
<p>On the other hand, if you don’t take careful precautions, variables existing across the entirety of a scope can lead to some unexpected pitfalls.</p>
<p>其他方面来说，如果你不做预防，变量穿过这个变量会带来不可估计的陷阱。</p>
<h2 id="Hiding-In-Plain-Scope"><a href="#Hiding-In-Plain-Scope" class="headerlink" title="Hiding In Plain Scope"></a>Hiding In Plain Scope</h2><h2 id="隐藏在普通的作用域"><a href="#隐藏在普通的作用域" class="headerlink" title="隐藏在普通的作用域"></a>隐藏在普通的作用域</h2><p>The traditional way of thinking about functions is that you declare a function, and then add code inside it. But the inverse thinking is equally powerful and useful: take any arbitrary section of code you’ve written, and wrap a function declaration around it, which in effect “hides” the code.</p>
<p>对方法传统的看法是声明一个方法，然后在里面加代码。但是相反的现在的看法趋向有力和有用:取任意部分你写的代码，然后声明一个方法把它包起来，有效的把代码”隐藏”起来。</p>
<p>The practical result is to create a scope bubble around the code in question, which means that any declarations (variable or function) in that code will now be tied to the scope of the new wrapping function, rather than the previously enclosing scope. In other words, you can “hide” variables and functions by enclosing them in the scope of a function.</p>
<p>其实际结果是在代码周围创建了一个作用域气泡，意思是方法中任何的声明(方法或者变量)将会被新包围的方法的作用域约束，也不是先前包围的作用域。换句话来说，你可以将变量和方法用方法的作用域包围”藏”起来。</p>
<p>Why would “hiding” variables and functions be a useful technique?</p>
<p>为什么”隐藏”变量和方法会是有用的技巧？</p>
<p>There’s a variety of reasons motivating this scope-based hiding. They tend to arise from the software design principle “Principle of Least Privilege” [^note-leastprivilege], also sometimes called “Least Authority” or “Least Exposure”. This principle states that in the design of software, such as the API for a module/object, you should expose only what is minimally necessary, and “hide” everything else.</p>
<p>有各种各样的原因去鼓励作用域为基础的隐藏。这个设计来自于软件设计原则”最小特权原则”[^note-leastprivilege]，有时候也被叫做”最小权限”或者”最小暴露”。这个原则是软件设计的通常说法，用于模块/对象的API，你只能暴露需要的最小东西，然后将其他的都”隐藏”起来。</p>
<p>This principle extends to the choice of which scope to contain variables and functions. If all variables and functions were in the global scope, they would of course be accessible to any nested scope. But this would violate the “Least…” principle in that you are (likely) exposing many variables or functions which you should otherwise keep private, as proper use of the code would discourage access to those variables/functions.</p>
<p>这个原则延伸到选择哪个作用域来包含变量和方法。如果所有变量和方法在全局作用域中,他们当然可以被任何嵌套的作用域访问。但是这违反了”最小…”原则因为你会(大概)暴露多个你需要保持私有的变量或者方法，因为正确使用这些代码的方式是阻拦访问这些变量/方法。</p>
<p>For example:</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>In this snippet, the <code>b</code> variable and the <code>doSomethingElse(..)</code> function are likely “private” details of how <code>doSomething(..)</code> does its job. Giving the enclosing scope “access” to <code>b</code> and <code>doSomethingElse(..)</code> is not only unnecessary but also possibly “dangerous”, in that they may be used in unexpected ways, intentionally or not, and this may violate pre-condition assumptions of <code>doSomething(..)</code>.</p>
<p>在这段片段里,变量<code>b</code>和方法<code>doSomethingElse(..)</code>就好像<code>doSomething(..)</code>的”私有”细节。给包围他的作用域“存取” <code>b</code>和<code>doSomethingElse(..)</code>不仅仅是多余的而且可能是”危险”的,可能通过一些出乎意料的方式，故意的或者又不是,这可能违反了 <code>doSomething(..)</code>提前设定的责任。</p>
<p>A more “proper” design would hide these private details inside the scope of <code>doSomething(..)</code>, such as:</p>
<p>一个更”恰当”的设计会是隐藏<code>doSomething(..)</code>作用域的这些私有细节,类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">	b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>Now, <code>b</code> and <code>doSomethingElse(..)</code> are not accessible to any outside influence, instead controlled only by <code>doSomething(..)</code>. The functionality and end-result has not been affected, but the design keeps private details private, which is usually considered better software.</p>
<p>现在,<code>b</code> 和 <code>doSomethingElse(..)</code>将不受任何外部的影响不可读取,相反的只受<code>doSomething(..)</code>的控制。方法和最后的结果将不被受影响,设计为保持私有细节为私有,这通常被认为是更好的软件设计。</p>
<h3 id="Collision-Avoidance"><a href="#Collision-Avoidance" class="headerlink" title="Collision Avoidance"></a>Collision Avoidance</h3><h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>Another benefit of “hiding” variables and functions inside a scope is to avoid unintended collision between two different identifiers with the same name but different intended usages. Collision results often in unexpected overwriting of values.</p>
<p>把变量和方法放在作用域里隐藏的另外一个好处是避免两个不同的标识符有相同的名字但是不同的用法的无意间的冲突。冲突结果经常是出乎意料的覆盖重写了值。</p>
<p>For example:</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">		i = <span class="number">3</span>; <span class="comment">// changing the `i` in the enclosing scope's for-loop</span></span><br><span class="line">		<span class="built_in">console</span>.log( a + i );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		bar( i * <span class="number">2</span> ); <span class="comment">// oops, infinite loop ahead!</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>The <code>i = 3</code> assignment inside of <code>bar(..)</code> overwrites, unexpectedly, the <code>i</code> that was declared in <code>foo(..)</code> at the for-loop. In this case, it will result in an infinite loop, because <code>i</code> is set to a fixed value of <code>3</code> and that will forever remain <code>&lt; 10</code>.</p>
<p><code>i</code>在<code>foo(..)</code>中被声明并且循环,出乎意料的,<code>bar(..)</code>内部的<code>i = 3</code>赋值操作将他覆盖重写了。在这种情况下，结果将会是一个无线循环，因为<code>i</code>被设置成一个固定的值<code>3</code>结果将永远小于<code>&lt; 10</code>。</p>
<p>The assignment inside <code>bar(..)</code> needs to declare a local variable to use, regardless of what identifier name is chosen. <code>var i = 3;</code> would fix the problem (and would create the previously mentioned “shadowed variable” declaration for <code>i</code>). An <em>additional</em>, not alternate, option is to pick another identifier name entirely, such as <code>var j = 3;</code>. But your software design may naturally call for the same identifier name, so utilizing scope to “hide” your inner declaration is your best/only option in that case.</p>
<p><code>bar(..)</code>内部的赋值操作需要声明一个本地的变量来使用,不论选择什么名字的标识符。<code>var i = 3;</code>会修复这个问题(将会创建于一个之前提到过的为i声明”遮蔽变量”)。此外,一个非代替的选项就是取完全不同的另外一个标识符，类似<code>var j = 3;</code>。但是你的软件原本的设计可能就是相同的标识符名称,所以这种情况下利用作用域”隐藏”内部的声明是你最好的选择。</p>
<h4 id="Global-“Namespaces”"><a href="#Global-“Namespaces”" class="headerlink" title="Global “Namespaces”"></a>Global “Namespaces”</h4><h4 id="全局”命名空间”"><a href="#全局”命名空间”" class="headerlink" title="全局”命名空间”"></a>全局”命名空间”</h4><p>A particularly strong example of (likely) variable collision occurs in the global scope. Multiple libraries loaded into your program can quite easily collide with each other if they don’t properly hide their internal/private functions and variables.</p>
<p>变量冲突发生在全局作用域中一个特别常见的例子(基本上)。在你的程序中加载多个库如果他们没有更好的把他们的内部的/私有的方法和变量隐藏起来那么很容易就会发生冲突。</p>
<p>Such libraries typically will create a single variable declaration, often an object, with a sufficiently unique name, in the global scope. This object is then used as a “namespace” for that library, where all specific exposures of functionality are made as properties off that object (namespace), rather than as top-level lexically scoped identifiers themselves.</p>
<p>这类库通常会创建一个单独的变量声明，一般是一个对象，在全局作用域中用一个完全唯一的名称。这个对象作为库的一个”命名空间”被使用，所有的方法都作为对象(命名空间)的属性明确的暴露，而不是把自己作为最高层的词法作用标识符。</p>
<p>For example:</p>
<p>举例来说:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">	awesome: <span class="string">"stuff"</span>,</span><br><span class="line">	doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;,</span><br><span class="line">	doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Module-Management"><a href="#Module-Management" class="headerlink" title="Module Management"></a>Module Management</h4><h4 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h4><p>Another option for collision avoidance is the more modern “module” approach, using any of various dependency managers. Using these tools, no libraries ever add any identifiers to the global scope, but are instead required to have their identifier(s) be explicitly imported into another specific scope through usage of the dependency manager’s various mechanisms.</p>
<p>避免冲突的另外一个选项是更现代化的”模块”方式，使用各种各样的任何一种依赖管理。使用这些工具，没有任何库会增加任何一个标识符到全局作用域中，但是相反的需要把他们的标识符明确的输入到特定的作用域中依赖管理器各种各样的机制来使用。</p>
<p>It should be observed that these tools do not possess “magic” functionality that is exempt from lexical scoping rules. They simply use the rules of scoping as explained here to enforce that no identifiers are injected into any shared scope, and are instead kept in private, non-collision-susceptible scopes, which prevents any accidental scope collisions.</p>
<p>应该可以看到这些工具不具有躲避词法作用域规则的”魔法”方法。他简单的使用这里讲解的作用域规则来强迫没有标识可以注入到任何共享的作用域中，相反的是保持私有的，无冲突不会受影响的作用域中，阻止任何偶然的作用域冲突创建。</p>
<p>As such, you can code defensively and achieve the same results as the dependency managers do without actually needing to use them, if you so choose. See the Chapter 5 for more information about the module pattern.</p>
<p>所以,如果你这样选择的话，你可以写防御性代码在不使用管理器的情况下达到同样的效果。见第五章获得更多模块模式的信息。</p>
<h2 id="Functions-As-Scopes"><a href="#Functions-As-Scopes" class="headerlink" title="Functions As Scopes"></a>Functions As Scopes</h2><h2 id="方法作用域-1"><a href="#方法作用域-1" class="headerlink" title="方法作用域"></a>方法作用域</h2><p>We’ve seen that we can take any snippet of code and wrap a function around it, and that effectively “hides” any enclosed variable or function declarations from the outside scope inside that function’s inner scope.</p>
<p>我们知道我们可以任何一段代码然后用一个方法保住，然后有效的在作用域内部对外部的作用域”隐藏”任何被包围的变量或者方法声明。</p>
<p>For example:</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;-- insert this</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// &lt;-- and this</span></span><br><span class="line">foo(); <span class="comment">// &lt;-- and this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>While this technique “works”, it is not necessarily very ideal. There are a few problems it introduces. The first is that we have to declare a named-function <code>foo()</code>, which means that the identifier name <code>foo</code> itself “pollutes” the enclosing scope (global, in this case). We also have to explicitly call the function by name (<code>foo()</code>) so that the wrapped code actually executes.</p>
<p>尽管这个技巧可以”工作”,这并非是个很好的注意。这样有几个问题需要介绍。首先我们声明了一个被取了名字的方法<code>foo()</code>，这意味着标识符名称<code>foo</code>“污染”了包围的作用域(全局,在这个例子里)。我们任然可以直接使用名称调用方法(<code>foo()</code>)所以实际上包裹的代码还是执行了。</p>
<p>It would be more ideal if the function didn’t need a name (or, rather, the name didn’t pollute the enclosing scope), and if the function could automatically be executed.</p>
<p>如果方法不需要名字(或者至少这个名字不会污染所属的作用域),而且这个方法可以自动被执行那我们就有更多的办法了。</p>
<p>Fortunately, JavaScript offers a solution to both problems.</p>
<p>幸运的是,JavaScript提供了解决全部问题的解决方案。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- insert this</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;)(); <span class="comment">// &lt;-- and this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Let’s break down what’s happening here.</p>
<p>让我们拆解下这里发生了什么。</p>
<p>First, notice that the wrapping function statement starts with <code>(function...</code> as opposed to just <code>function...</code>. While this may seem like a minor detail, it’s actually a major change. Instead of treating the function as a standard declaration, the function is treated as a function-expression.</p>
<p>首先,注意到一个包裹的方法声明以<code>(function...</code>开始代替<code>function...</code>。尽管这好像是微小的细节，事实上这是最主要的改变。方法被对待为一个方法表达式取代对待方法为一个标准的声明。</p>
<p><strong>Note:</strong> The easiest way to distinguish declaration vs. expression is the position of the word “function” in the statement (not just a line, but a distinct statement). If “function” is the very first thing in the statement, then it’s a function declaration. Otherwise, it’s a function expression.</p>
<p><strong>注意:</strong> 最简单区分声明和表达式方式是单词”function”在声明的位置(不仅仅是一行,而是明确的表达式)。如果声明在最开始的地方出现”function”,那么就是方法声明,否则，就是方法表达式。</p>
<p>The key difference we can observe here between a function declaration and a function expression relates to where its name is bound as an identifier.</p>
<p>我们可以观察到方法声明和方法表达式最关键的区别是方法名称和识别符的绑定。</p>
<p>Compare the previous two snippets. In the first snippet, the name <code>foo</code> is bound in the enclosing scope, and we call it directly with <code>foo()</code>. In the second snippet, the name <code>foo</code> is not bound in the enclosing scope, but instead is bound only inside of its own function.</p>
<p>比较之前的两个代码片段。在第一个片段里，名称<code>foo</code>和包围他的作用域绑定，我们可以直接通过<code>foo()</code>来调用。在第二个片段，名称<code>foo</code>没有和包围的作用域绑定，但是相反的仅仅和他自己的方法绑定。</p>
<p>In other words, <code>(function foo(){ .. })</code> as an expression means the identifier <code>foo</code> is found <em>only</em> in the scope where the <code>..</code> indicates, not in the outer scope. Hiding the name <code>foo</code> inside itself means it does not pollute the enclosing scope unnecessarily.</p>
<p>换句话来说，<code>(function foo(){ .. })</code>作为一个表达式意味着标识符<code>foo</code><em>只能</em> 在<code>..</code>显示的作用域里找到，不能再外部的作用域中找到。将名称<code>foo</code>隐藏在自己内部意味着不会在不必要的情况下污染包围他的作用域。</p>
<h3 id="Anonymous-vs-Named"><a href="#Anonymous-vs-Named" class="headerlink" title="Anonymous vs. Named"></a>Anonymous vs. Named</h3><h3 id="匿名-vs-取名"><a href="#匿名-vs-取名" class="headerlink" title="匿名 vs. 取名"></a>匿名 vs. 取名</h3><p>You are probably most familiar with function expressions as callback parameters, such as:</p>
<p>你可能已经很熟悉方法表达式作为回调的参数,类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<p>This is called an “anonymous function expression”, because <code>function()...</code> has no name identifier on it. Function expressions can be anonymous, but function declarations cannot omit the name – that would be illegal JS grammar.</p>
<p>这被叫做一个”匿名方法表达式”,因为<code>function()...</code>没有名称标识符。方法表达式可以是匿名的，但是方法声明不可以遗漏名称 – 那将是不合法的JS语法。</p>
<p>Anonymous function expressions are quick and easy to type, and many libraries and tools tend to encourage this idiomatic style of code. However, they have several draw-backs to consider:</p>
<p>匿名方法表达式可以快速容易的编写，很多的库和方法倾向于鼓励这种理想风格的代码。然而，这里也有几个缺点需要考虑:</p>
<ol>
<li><p>Anonymous functions have no useful name to display in stack traces, which can make debugging more difficult.</p>
</li>
<li><p>匿名方法没有有用的名称在堆栈跟踪里显示，这让调试变得更加困难。</p>
</li>
<li><p>Without a name, if the function needs to refer to itself, for recursion, etc., the <strong>deprecated</strong> <code>arguments.callee</code> reference is unfortunately required. Another example of needing to self-reference is when an event handler function wants to unbind itself after it fires.</p>
</li>
<li><p>没有了名字,如果方法需要引用他自己，来重新执行，等等，那不幸的需要使用<strong>不推荐的</strong><code>arguments.callee</code>来引用。另外需要自己引用的例子是当一个事件处理者需要在触发后解绑他的自己的情况。</p>
</li>
<li><p>Anonymous functions omit a name that is often helpful in providing more readable/understandable code. A descriptive name helps self-document the code in question.</p>
</li>
<li><p>匿名方法省略了名字而名字常常有助于带来更多的可读性/可理解性代码。一个描述的名字在有问题的时候可以帮助作为代码自己的文档。</p>
</li>
</ol>
<p><strong>Inline function expressions</strong> are powerful and useful – the question of anonymous vs. named doesn’t detract from that. Providing a name for your function expression quite effectively addresses all these draw-backs, but has no tangible downsides. The best practice is to always name your function expressions:</p>
<p><strong>内联方法表达式</strong> 是很强大和有用的 – 匿名 vs. 取名问题没有贬低他。给你方法提供一个名字会非常有效的解决所有的缺点,而且没有实质上的缺点。最佳的实践是永远给你的方法表达式取名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- Look, I have a name!</span></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"I waited 1 second!"</span> );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<h3 id="Invoking-Function-Expressions-Immediately"><a href="#Invoking-Function-Expressions-Immediately" class="headerlink" title="Invoking Function Expressions Immediately"></a>Invoking Function Expressions Immediately</h3><h3 id="立刻执行方法表达式"><a href="#立刻执行方法表达式" class="headerlink" title="立刻执行方法表达式"></a>立刻执行方法表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Now that we have a function as an expression by virtue of wrapping it in a <code>( )</code> pair, we can execute that function by adding another <code>()</code> on the end, like <code>(function foo(){ .. })()</code>. The first enclosing <code>( )</code> pair makes the function an expression, and the second <code>()</code> executes the function.</p>
<p>现在我们有了一个方法作为表达式凭借一对<code>( )</code>包裹，我们可以在最后增加另外一对<code>()</code>来调用，就像<code>(function foo(){ .. })()</code>。第一对包括的<code>( )</code>让方法变成一个表达式，然后第二对<code>()</code>执行了这个方法。</p>
<p>This pattern is so common, a few years ago the community agreed on a term for it: <strong>IIFE</strong>, which stands for <strong>I</strong>mmediately <strong>I</strong>nvoked <strong>F</strong>unction <strong>E</strong>xpression.</p>
<p>这个模式是很常见的，几年之前社区就为这个模式达成了一个术语叫做： <strong>IIFE</strong>，他就代表<strong>I</strong>mmediately <strong>I</strong>nvoked <strong>F</strong>unction <strong>E</strong>xpression。</p>
<p>Of course, IIFE’s don’t need names, necessarily – the most common form of IIFE is to use an anonymous function expression. While certainly less common, naming an IIFE has all the aforementioned benefits over anonymous function expressions, so it’s a good practice to adopt.</p>
<p>当然,IIFE不需要名称，名字不是必须的 – 最常见的IIFE是使用匿名的方法表达式。虽然确实比常见的少，但有名字的IIFE相比匿名表达式拥有所有上述提到过的益处，所以采用这个是一个好的实践。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>There’s a slight variation on the traditional IIFE form, which some prefer: <code>(function(){ .. }())</code>. Look closely to see the difference. In the first form, the function expression is wrapped in <code>( )</code>, and then the invoking <code>()</code> pair is on the outside right after it. In the second form, the invoking <code>()</code> pair is moved to the inside of the outer <code>( )</code> wrapping pair.</p>
<p>这是在传统的IIFE上稍加变化，虽然有些人偏好<code>(function(){ .. }())</code>。仔细观察可以看出不同。在第一个形式中，方法表达式被<code>( )</code>包围，然后用一对放在外部在右边紧随其后的<code>()</code>触发。在第二个形式中，用于触发的一对<code>()</code>被移动到了外部用于包围的一对<code>( )</code>里面。</p>
<p>These two forms are identical in functionality. <strong>It’s purely a stylistic choice which you prefer.</strong></p>
<p>这两种形式在方法中完全相同。<strong>这完全是一个代码风格的选择取决你更喜欢哪个</strong>。</p>
<p>Another variation on IIFE’s which is quite common is to use the fact that they are, in fact, just function calls, and pass in argument(s).</p>
<p>另外一种非常常见的IIFE的变化是使用最真实的自己，事实上，只是调用方法，然后将参数传进去。</p>
<p>For instance:</p>
<p>举例来说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> global </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log( global.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>We pass in the <code>window</code> object reference, but we name the parameter <code>global</code>, so that we have a clear stylistic delineation for global vs. non-global references. Of course, you can pass in anything from an enclosing scope you want, and you can name the parameter(s) anything that suits you. This is mostly just stylistic choice.</p>
<p>我们传入一个<code>window</code>对象的引用，但是我们给参数取名为<code>global</code>，这样我们对全局vs.非全局引用有了一个清楚的文体上的的解释。当然，你可以传入任何你想要的来自包围你的作用域的东西，然后你可以给参数取任何你觉得合适的名字。这大多情况下只是代码风格的选择。</p>
<p>Another application of this pattern addresses the (minor niche) concern that the default <code>undefined</code> identifier might have its value incorrectly overwritten, causing unexpected results. By naming a parameter <code>undefined</code>, but not passing any value for that argument, we can guarantee that the <code>undefined</code> identifier is in fact the undefined value in a block of code:</p>
<p>这个模式另外一种应用是设法解决(微小的问题)考虑到默认的<code>undefined</code>标识符可能会被不正确的值重写，造成出乎意料的结果。给参数取名为<code>undefined</code>，但是不传入任何值给参数，这样我们可以保证<code>undefined</code>标识符在这段代码的内部是undefined本身的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>; <span class="comment">// setting a land-mine for other code! avoid!</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> undefined </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line">	<span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Undefined is safe here!"</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>Still another variation of the IIFE inverts the order of things, where the function to execute is given second, <em>after</em> the invocation and parameters to pass to it. This pattern is used in the UMD (Universal Module Definition) project. Some people find it a little cleaner to understand, though it is slightly more verbose.</p>
<p>任然是IIFE的另外一种变化是颠倒事情的顺序，将方法调用放在第二步，在调用和将参数传入<em>之后</em>。这个模式在UMD(Universal Module Definition)项目中被使用。有些人发现这会更清楚被理解，虽然这有些轻微的冗长。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>)</span>&#123;</span><br><span class="line">	def( <span class="built_in">window</span> );</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log( global.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The <code>def</code> function expression is defined in the second-half of the snippet, and then passed as a parameter (also called <code>def</code>) to the <code>IIFE</code> function defined in the first half of the snippet. Finally, the parameter <code>def</code> (the function) is invoked, passing <code>window</code> in as the <code>global</code> parameter.</p>
<p><code>def</code>方法表达式被定义在代码片段的第二部分，然后被作为参数(仍然叫做<code>def</code>)传入被定义在代码片段第一部分的<code>IIFE</code>方法。最后，参数<code>def</code>(那个方法)被调用，传入<code>window</code>作为<code>global</code>参数。</p>
<h2 id="Blocks-As-Scopes"><a href="#Blocks-As-Scopes" class="headerlink" title="Blocks As Scopes"></a>Blocks As Scopes</h2><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>While functions are the most common unit of scope, and certainly the most wide-spread of the design approaches in the majority of JS in circulation, other units of scope are possible, and the usage of these other scope units can lead to even better, cleaner to maintain code.</p>
<p>尽管方法是最常见作用域单元，无疑是在大多数JS流传最广的设计中传播最广的，但是其他作用域的单位也是合理的，使用这些其他单位的作用域可以更好，更清楚的维护代码。</p>
<p>Many languages other than JavaScript support Block Scope, and so developers from those languages are accustomed to the mindset, whereas those who’ve primarily only worked in JavaScript may find the concept slightly foreign.</p>
<p>许多其他的语言相比JavaScript支持块作用域，所以这些语言的开发者习惯于这个观点，然而对那些主要使用JavaScript工作的人来说这个观点有些陌生。</p>
<p>But even if you’ve never written a single line of code in block-scoped fashion, you are still probably familiar with this extremely common idiom in JavaScript:</p>
<p>但是即使你没有写过一行块作用域风格的代码，你仍然可能熟悉这个极度常见JavaScript语法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We declare the variable <code>i</code> directly inside the for-loop head, most likely because our <em>intent</em> is to use <code>i</code> only within the context of that for-loop, and essentially ignore the fact that the variable actually scopes itself to the enclosing scope (function or global).</p>
<p>我们直接在for循环的头部声明了变量<code>i</code>，很像块作用域的写法因为我们的<em>目的</em>是只在for循环的内部使用<code>i</code>，然后本质上忽略了一个事实变量实际上属于包围他的作用域(方法或者全局作用域)。</p>
<p>That’s what block-scoping is all about. Declaring variables as close as possible, as local as possible, to where they will be used. Another example:</p>
<p>这就是关于块级作用域。声明变量对于他要使用的地方越封闭越好，越本地越好(译者注:变量只属于使用他的块作用域)。另外一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">	bar = something( bar );</span><br><span class="line">	<span class="built_in">console</span>.log( bar );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We are using a <code>bar</code> variable only in the context of the if-statement, so it makes a kind of sense that we would declare it inside the if-block. However, where we declare variables is not relevant when using <code>var</code>, because they will always belong to the enclosing scope. This snippet is essentially “fake” block-scoping, for stylistic reasons, and relying on self-enforcement not to accidentally use <code>bar</code> in another place in that scope.</p>
<p>我们只在if表达式的块内部使用变量<code>bar</code>，所以这有点我们只在if块的内部声明他的意思。然而，我们在哪里声明变量并不取决于我们什么时候使用<code>var</code>，因为变量始终属于包围他的作用域。这个片段本质上是”伪装”成块作用域，因为代码风格的原因，假装强迫自己不能再意外的情况下在作用域的其他地方使用<code>bar</code>。</p>
<p>Block scope is a tool to extend the earlier “Principle of Least <del>Privilege</del> Exposure” [^note-leastprivilege] from hiding information in functions to hiding information in blocks of our code.</p>
<p>块作用域是更简单的扩展”最小原则 <del>特权</del> 暴露”[^note-leastprivilege]的工具，让我们的代码从隐藏信息到方法里到隐藏信息到块里。</p>
<p>Consider the for-loop example again:</p>
<p>再考虑一下for循环的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Why pollute the entire scope of a function with the <code>i</code> variable that is only going to be (or only <em>should be</em>, at least) used for the for-loop?</p>
<p>为什么变量<code>i</code>只会在(或者至少应该在)for循环中使用却要污染整个作用域？</p>
<p>But more importantly, developers may prefer to <em>check</em> themselves against accidentally (re)using variables outside of their intended purpose, such as being issued an error about an unknown variable if you try to use it in the wrong place. Block-scoping (if it were possible) for the <code>i</code> variable would make <code>i</code> available only for the for-loop, causing an error if <code>i</code> is accessed elsewhere in the function. This helps ensure variables are not re-used in confusing or hard-to-maintain ways.</p>
<p>但是更重要的，开发者最好去<em>检查</em>他自己以防在目的以外的地方无意的使用(再使用)变量，如果你在错误的地方使用变量会引起不知道变量的错误。在块作用域(如果可能的话)中变量<code>i</code>会使变量<code>i</code>只属于for循环，如果<code>i</code>在方法的其他地方被读取将引发错误。这有助于确保变量不会被不清楚的方式或者难以维护的方式被使用。</p>
<p>But, the sad reality is that, on the surface, JavaScript has no facility for block scope.</p>
<p>但是，悲伤的现实是，从表面上看，JavaScript没有块作用域的能力。(facility:a natural ability to learn or do sth easily)</p>
<p>That is, until you dig a little further.</p>
<p>至少目前来看是这样，除非你挖掘更深入一些。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h3><p>We learned about <code>with</code> in Chapter 2. While it is a frowned upon construct, it <em>is</em> an example of (a form of) block scope, in that the scope that is created from the object only exists for the lifetime of that <code>with</code> statement, and not in the enclosing scope.</p>
<p>我们在第二章已经学过<code>with</code>。尽管这是一个让人皱眉的概念，但是他<em>是</em>一种块作用域的例子(形式)，从对象创建的作用域和对象本身只存在于<code>with</code>表达式的生命周期，而不在包围他的作用域中。</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a><code>try/catch</code></h3><p>It’s a <em>very</em> little known fact that JavaScript in ES3 specified the variable declaration in the <code>catch</code> clause of a <code>try/catch</code> to be block-scoped to the <code>catch</code> block.</p>
<p>一个很少知道的事实是JavaScript在ES3提出在<code>try/catch</code>中的<code>catch</code>分句中是一个块级作用域声明在里面的变量只属于<code>catch</code>。</p>
<p>For instance:</p>
<p>事例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="literal">undefined</span>(); <span class="comment">// illegal operation to force an exception!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( err ); <span class="comment">// works!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( err ); <span class="comment">// ReferenceError: `err` not found</span></span><br></pre></td></tr></table></figure>
<p>As you can see, <code>err</code> exists only in the <code>catch</code> clause, and throws an error when you try to reference it elsewhere.</p>
<p>就像你看到的,<code>err</code>只存在于<code>catch</code>分句里,当你在任何其他地方尝试引用他都将抛出一个错误。</p>
<p><strong>Note:</strong> While this behavior has been specified and true of practically all standard JS environments (except perhaps old IE), many linters seem to still complain if you have two or more <code>catch</code> clauses in the same scope which each declare their error variable with the same identifier name. This is not actually a re-definition, since the variables are safely block-scoped, but the linters still seem to, annoyingly, complain about this fact.</p>
<p><strong>注意:</strong> 虽然这个表现方式已经被明确规定而且在几乎所有的标准JS环境中都是正确的(也许除了老IE)，但是如果你在同一个作用域中有两个或者多个<code>catch</code>分句将错误变量用同样的标识符声明那么许多的linter还是回警告的。这事实上不是重复定义，因为每个变量在块级作用域中都是安全的，但是linters仍然把他们事实视作是错误的值得警告的。</p>
<p>To avoid these unnecessary warnings, some devs will name their <code>catch</code> variables <code>err1</code>, <code>err2</code>, etc. Other devs will simply turn off the linting check for duplicate variable names.</p>
<p>为了避免这些不必要的警告，一些开发者会将<code>catch</code>变量取名为<code>err1</code>, <code>err2</code>,等等。其他的开发者会简单的关闭linting的检查重复变量名称的开关。</p>
<p>The block-scoping nature of <code>catch</code> may seem like a useless academic fact, but see Appendix B for more information on just how useful it might be.</p>
<p><code>catch</code>的原本的块级作用域似乎看起来是无用的学术事实，但是如何使他更有用的信息见附录B。</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a><code>let</code></h3><p>Thus far, we’ve seen that JavaScript only has some strange niche behaviors which expose block scope functionality. If that were all we had, and <em>it was</em> for many, many years, then block scoping would not be terribly useful to the JavaScript developer.</p>
<p>因此，我们就可以看见JavaScript仅仅暴露一些奇怪举止的块级作用域方法。如果这就是我们拥有的关于块级作用域的全部，然而这确实是很多年<em>以来</em>我们所拥有的，那么这对JavaScript开发者也不会是非常有用的。</p>
<p>Fortunately, ES6 changes that, and introduces a new keyword <code>let</code> which sits alongside <code>var</code> as another way to declare variables.</p>
<p>幸运的是,ES6改变了这个，介绍了一个新的关键字<code>let</code>他和<code>var</code>一样但是作为另外一种声明变量的方式。</p>
<p>The <code>let</code> keyword attaches the variable declaration to the scope of whatever block (commonly a <code>{ .. }</code> pair) it’s contained in. In other words, <code>let</code> implicitly hijacks any block’s scope for its variable declaration.</p>
<p><code>let</code>关键字将变量申明依附在任何他所在的块级作用域中(通常是一对<code>{ .. }</code>)。换句话来说，<code>let</code>隐形的劫持任意一个块级作用域给变量声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">	bar = something( bar );</span><br><span class="line">	<span class="built_in">console</span>.log( bar );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>Using <code>let</code> to attach a variable to an existing block is somewhat implicit. It can confuse you if you’re not paying close attention to which blocks have variables scoped to them, and are in the habit of moving blocks around, wrapping them in other blocks, etc., as you develop and evolve code.</p>
<p>使用<code>let</code>使变量依附在一个存在的块上有些隐晦。如果在你开发设计代码的时候你没有仔细注意到变量所在的哪个块是他的作用域而是习惯性的将他在块之间移动将他包含在其他块里那这会让你混乱，</p>
<p>Creating explicit blocks for block-scoping can address some of these concerns, making it more obvious where variables are attached and not. Usually, explicit code is preferable over implicit or subtle code. This explicit block-scoping style is easy to achieve, and fits more naturally with how block-scoping works in other languages:</p>
<p>给块作用域创建明确的块可以处理一些这类顾虑，使变量是否依附某个块作用域更明显。一般来说。明确的代码比不明确或者不明显的代码更好。明确的块级作用域风格更容易达到某个目的，这也让JavaScript的块级作用域更像自他语言的块级作用域如何工作一般自然。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	&#123; <span class="comment">// &lt;-- explicit block</span></span><br><span class="line">		<span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">		bar = something( bar );</span><br><span class="line">		<span class="built_in">console</span>.log( bar );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>We can create an arbitrary block for <code>let</code> to bind to by simply including a <code>{ .. }</code> pair anywhere a statement is valid grammar. In this case, we’ve made an explicit block <em>inside</em> the if-statement, which may be easier as a whole block to move around later in refactoring, without affecting the position and semantics of the enclosing if-statement.</p>
<p>我们可以通过简单的写一对<code>{ .. }</code>来为<code>let</code>绑定创建任意块将表达式包含在里面这都是合理的语法。在这个情况里，我们在if表达式<em>里</em>创建一个明确的块，这也许让整个块移动和以后的重构更容易，也不会影响位置和if表达式包围块的意义。</p>
<p><strong>Note:</strong> For another way to express explicit block scopes, see Appendix B.</p>
<p><strong>注意:</strong> 表达明确块作用域的其他方式，见附录B。</p>
<p>In Chapter 4, we will address hoisting, which talks about declarations being taken as existing for the entire scope in which they occur.</p>
<p>在第四章中，我们会介绍提升，谈论关于声明会在他执行的整个作用域中存在。</p>
<p>However, declarations made with <code>let</code> will <em>not</em> hoist to the entire scope of the block they appear in. Such declarations will not observably “exist” in the block until the declaration statement.</p>
<p>然而，<code>let</code>声明将<em>不会</em>在在他执行的整个作用域中提升。这个声明将不会观察到”存在”于块中直到声明表达式执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError!</span></span><br><span class="line">   <span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h4><h4 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收(GC)"></a>垃圾回收(GC)</h4><p>Another reason block-scoping is useful relates to closures and garbage collection to reclaim memory. We’ll briefly illustrate here, but the closure mechanism is explained in detail in Chapter 5.</p>
<p>另外一个块作用域有用的原因是终止和执行垃圾回收来取回内存。我们会在这里简单的距离说明，但是终止机制的细节会在第五章解释。</p>
<p>Consider:</p>
<p>考虑一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// do something interesting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line">process( someReallyBigData );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line"></span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>The <code>click</code> function click handler callback doesn’t <em>need</em> the <code>someReallyBigData</code> variable at all. That means, theoretically, after <code>process(..)</code> runs, the big memory-heavy data structure could be garbage collected. However, it’s quite likely (though implementation dependent) that the JS engine will still have to keep the structure around, since the <code>click</code> function has a closure over the entire scope.</p>
<p><code>click</code>方法的click处理回调完全不<em>需要</em><code>someReallyBigData</code>变量。这意味着，理论上来说，在<code>process(..)</code>执行后，有大量的内存数据可以被垃圾回收。然而，很有可能(取决于整个实现)JS引擎将会任然保持这个结构，直到<code>click</code>方法整个作用域终止。</p>
<p>Block-scoping can address this concern, making it clearer to the engine that it does not need to keep <code>someReallyBigData</code> around:</p>
<p>块级作用域可以设法解决这个顾虑，是引擎不在需要保持<code>someReallyBigData</code>让他更干净：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// do something interesting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// anything declared inside this block can go away after!</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line">	process( someReallyBigData );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line"></span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>Declaring explicit blocks for variables to locally bind to is a powerful tool that you can add to your code toolbox.</p>
<p>为变量局部绑定声明明确的块是一个很强大的工具你可以加入到你的代码工具箱里。</p>
<h4 id="let-Loops"><a href="#let-Loops" class="headerlink" title="let Loops"></a><code>let</code> Loops</h4><h4 id="let-循环"><a href="#let-循环" class="headerlink" title="let 循环"></a><code>let</code> 循环</h4><p>A particular case where <code>let</code> shines is in the for-loop case as we discussed previously.</p>
<p><code>let</code>可以发光的一个特别的例子是我们之前讨论过的for循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>Not only does <code>let</code> in the for-loop header bind the <code>i</code> to the for-loop body, but in fact, it <strong>re-binds it</strong> to each <em>iteration</em> of the loop, making sure to re-assign it the value from the end of the previous loop iteration.</p>
<p>不仅仅是在for循环的头部<code>let</code>把<code>i</code>绑定在for循环的正文，事实上，每<em>循环</em>一次都<strong>重新绑定他</strong>，确保重新复制的值是上一次循环最后的值。</p>
<p>Here’s another way of illustrating the per-iteration binding behavior that occurs:</p>
<p>这里是另外一种方式来举例说明执行前一次绑定行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">let</span> i = j; <span class="comment">// re-bound for each iteration!</span></span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason why this per-iteration binding is interesting will become clear in Chapter 5 when we discuss closures.</p>
<p>前一次循环绑定为什么有趣在我们第五章讨论闭包的时候就清楚了。</p>
<p>Because <code>let</code> declarations attach to arbitrary blocks rather than to the enclosing function’s scope (or global), there can be gotchas where existing code has a hidden reliance on function-scoped <code>var</code> declarations, and replacing the <code>var</code> with <code>let</code> may require additional care when refactoring code.</p>
<p>因为<code>let</code>声明依附于任意一个块而不是包含他的方法作用于(或者全局作用域)，所以在重构代码时将<code>var</code>替换成<code>let</code>时，需要抓住隐藏依赖于<code>var</code>声明的作用域上的已经存在的代码，需要额外的关心。</p>
<p>Consider:</p>
<p>考虑一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( baz );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code is fairly easily re-factored as:</p>
<p>这个代码相当简单的重构为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( baz );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But, be careful of such changes when using block-scoped variables:</p>
<p>但是，当使用块级作用域改变这种情况是要小心：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">let</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (baz &gt; bar) &#123; <span class="comment">// &lt;-- don't forget `bar` when moving!</span></span><br><span class="line">		<span class="built_in">console</span>.log( baz );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See Appendix B for an alternate (more explicit) style of block-scoping which may provide easier to maintain/refactor code that’s more robust to these scenarios.</p>
<p>附录B介绍了一种块作用域的（更明确）替代形式它可能会提供在这些场景下更易于维护/重构的更健壮的代码。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h3><p>In addition to <code>let</code>, ES6 introduces <code>const</code>, which also creates a block-scoped variable, but whose value is fixed (constant). Any attempt to change that value at a later time results in an error.</p>
<p>除了<code>let</code>之外，ES6还介绍了<code>const</code>，虽然他也创建一个块级作用域的变量，但是他的值是固定的(常数)。任何在晚些时候试图修改他值的结果都是一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> b = <span class="number">3</span>; <span class="comment">// block-scoped to the containing `if`</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">3</span>; <span class="comment">// just fine!</span></span><br><span class="line">	b = <span class="number">4</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// ReferenceError!</span></span><br></pre></td></tr></table></figure>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><h2 id="回顾-TL-DR"><a href="#回顾-TL-DR" class="headerlink" title="回顾 (TL;DR)"></a>回顾 (TL;DR)</h2><p>Functions are the most common unit of scope in JavaScript. Variables and functions that are declared inside another function are essentially “hidden” from any of the enclosing “scopes”, which is an intentional design principle of good software.</p>
<p>方法在JavaScript中是最常见的作用域单位。在另外一个方法中声明的变量和方法本质上”隐藏”于任何外部的”作用域”，这是传统设计观念中更好的软件。</p>
<p>But functions are by no means the only unit of scope. Block-scope refers to the idea that variables and functions can belong to an arbitrary block (generally, any <code>{ .. }</code> pair) of code, rather than only to the enclosing function.</p>
<p>但是方法并不是唯一的作用于单位。块级作用域提到变量和方法可以属于任意一个块(通常,任意一对<code>{ .. }</code>)的代码而不是仅仅属于包围他的方法。</p>
<p>Starting with ES3, the <code>try/catch</code> structure has block-scope in the <code>catch</code> clause.</p>
<p>从ES3开始，<code>try/catch</code>结构中的<code>catch</code>分句是块级作用域。</p>
<p>In ES6, the <code>let</code> keyword (a cousin to the <code>var</code> keyword) is introduced to allow declarations of variables in any arbitrary block of code. <code>if (..) { let a = 2; }</code> will declare a variable <code>a</code> that essentially hijacks the scope of the <code>if</code>‘s <code>{ .. }</code> block and attaches itself there.</p>
<p>在ES6中，介绍了<code>let</code>关键字(<code>var</code>关键字的表兄)它允许被声明的变量属于任意一个代码块，<code>if (..) { let a = 2; }</code>声明了变量<code>a</code> 他劫持了<code>if</code>的<code>{ .. }</code>块作用域然后将自己依附于这个块作用域上。</p>
<p>Though some seem to believe so, block scope should not be taken as an outright replacement of <code>var</code> function scope. Both functionalities co-exist, and developers can and should use both function-scope and block-scope techniques where respectively appropriate to produce better, more readable/maintainable code.</p>
<p>虽然有些人似乎这么认为，但块作用域应该不能被认为是用来完全替代<code>var</code>方法作用域的。两个方法共存，开发者可以和应该同时使用方法作用域和块作用域技巧来分别适当的使用让程序更好，使代码更可读/可维护。</p>
<p>[^note-leastprivilege]: <a href="http://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener">Principle of Least Privilege</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/29/You-Don-t-Know-JS-Scope-Closures-Chapter-3-Function-vs-Block-Scope/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 jackiecookie
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.266c1c.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.096dc6.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br> npm i hexo-generator-json-content --save<br><br>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">潘迪海@杭州</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>